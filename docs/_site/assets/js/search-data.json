{"0": {
    "doc": "LED Blinking",
    "title": "LED Blinking Hardware",
    "content": ". The LED circuit is effectively four LEDs that are independently controlled using four different GPIO pins of the ATMEGA328P. Figure X. LED Blinking Circuit . These LEDs are cycled on and off using a simple blink program providing a trivial aesthetic effect, but its primary purpose is the functional verification of the ATMEGA328P. The visual indicator allows the user to determine if the microcontroller is bootloaded, which means it is capable of receiving code uploads. This check is particularly important as discrete ATMEGA328P chips are typically sold without a pre-installed bootloader. ",
    "url": "/hardware/atinverter_v2/LED_blinking_hw.html#led-blinking-hardware",
    
    "relUrl": "/hardware/atinverter_v2/LED_blinking_hw.html#led-blinking-hardware"
  },"1": {
    "doc": "LED Blinking",
    "title": "LED Blinking",
    "content": ". ",
    "url": "/hardware/atinverter_v2/LED_blinking_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/LED_blinking_hw.html"
  },"2": {
    "doc": "St. Thomas Inverter Specs",
    "title": "University of St. Thomas Specifications",
    "content": ". mindmap root((Power Inverter Specifications)) **Ratings** Power Rating: 200W Output Voltage: 120V Input Voltage: 12V DC / 24V DC Frequency: 60Hz **Droop Control** Frequency Droop: 60Hz to 57.6Hz at full load Voltage Droop: 120V to 115.2V at full load **Protection Features** Overload Protection Short Circuit Protection Over/Under Voltage Protection Thermal Shutdown **Cooling** Passive cooling with Aluminum sinks **Application** Educational Kits: 3 Kits for K-12 Program Research Kit: 1 Kit developed by UST . ",
    "url": "/hardware/ST_HW.html#university-of-st-thomas-specifications",
    
    "relUrl": "/hardware/ST_HW.html#university-of-st-thomas-specifications"
  },"3": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Ratings",
    "content": ". | Power Rating: 200W | Output Voltage: 120V | Input voltage: 12V DC/24V DC | Frequency: 60Hz | . ",
    "url": "/hardware/ST_HW.html#ratings",
    
    "relUrl": "/hardware/ST_HW.html#ratings"
  },"4": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Droop Control",
    "content": ". | Frequency Droop: 60Hz to 57.6 Hz at full load | Voltage Droop: 120V ‚Äì 115.2V at full load | . ",
    "url": "/hardware/ST_HW.html#droop-control",
    
    "relUrl": "/hardware/ST_HW.html#droop-control"
  },"5": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Protection Features",
    "content": ". | Overload Protection | Short Circuit Protection | Over/Under Voltage Protection | Thermal Shutdown | . ",
    "url": "/hardware/ST_HW.html#protection-features",
    
    "relUrl": "/hardware/ST_HW.html#protection-features"
  },"6": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Cooling",
    "content": ". | Passive cooling with Aluminum sinks | . ",
    "url": "/hardware/ST_HW.html#cooling",
    
    "relUrl": "/hardware/ST_HW.html#cooling"
  },"7": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Application",
    "content": ". | 3 Educational kits for k-12 program enclosed in a shield/box with access to inputs, outputs, and Arduino port | 1 Research kit that will be developed by UST | . ",
    "url": "/hardware/ST_HW.html#application",
    
    "relUrl": "/hardware/ST_HW.html#application"
  },"8": {
    "doc": "St. Thomas Inverter Specs",
    "title": "St. Thomas Inverter Specs",
    "content": " ",
    "url": "/hardware/ST_HW.html",
    
    "relUrl": "/hardware/ST_HW.html"
  },"9": {
    "doc": "Atinverter V1 Hardware",
    "title": "Atinverter V1 Hardware",
    "content": ". The website focuses on the documentation of the Atinverter V2, but to learn more about the hardware design and implementation for the Atinverter V1, please refer to the Atinverter V1 Report. ",
    "url": "/hardware/a_v1_hw.html",
    
    "relUrl": "/hardware/a_v1_hw.html"
  },"10": {
    "doc": "Atinverter V1 Software",
    "title": "Atinverter V1 Software",
    "content": ". The website focuses on the documentation of the Atinverter V2, but to learn more about the software design and implementation for the Atinverter V1, please refer to the Atinverter V1 Report. ",
    "url": "/software/a_v1_sw.html",
    
    "relUrl": "/software/a_v1_sw.html"
  },"11": {
    "doc": "Atinverter V2 Hardware",
    "title": "Atinverter V2 Hardware",
    "content": ". The Atinverter Version 2 (V2) incorporates a multitude of subsystems that work in tandem to support the board‚Äôs main function as a power inverter. A power inverter, not to be confused with a digital logic inverter, is a type of converter that takes a DC input and transforms it to an AC output. üí≠ ‚ÄúWhy Atinverter?‚Äù . The name ‚ÄúAtinverter‚Äù reflects the close relationship between the ATMEGA328P microcontroller (MCU) and the inverter circuitry, combining ‚ÄúATMEGA328P‚Äù and ‚Äúinverter‚Äù into a single term. The diagram below illustrates the core components and the interconnections of the design: . Figure X. Atinverter High Level Block Diagram . ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html#atinverter-v2-hardware",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html#atinverter-v2-hardware"
  },"12": {
    "doc": "Atinverter V2 Hardware",
    "title": "Systems",
    "content": "To better understand the full scope of the Atinverter V2, it‚Äôs helpful to explore the various systems in more detail. Click on each section to dive deeper into how each subsystem contributes to the overall design. | üîå Power Inverter | üìü DC Voltage Sensing | üìü DC Current Sensing | üìü AC Voltage Sensing | üìü AC Current Sensing | ‚ö° Overvoltage and Reset Protection | üîΩ Buck Converter | üîº Boost Converter | üí° LED Blinking | üîÅ Inter-Board Communication | . ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html#systems",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html#systems"
  },"13": {
    "doc": "Atinverter V2 Hardware",
    "title": "Atinverter V2 Hardware",
    "content": " ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html"
  },"14": {
    "doc": "Atinverter V2 Software",
    "title": "Atinverter V2 Software",
    "content": ". The Atinverter V2 codebase is composed of a Library folder as well as well various module folders (Blink, Main, PWM_Inverting, and VI_Sensing). The Atinverter library contains the object-oriented coding framework that allows for intuitive intialization, control, and sensing of the Atinverter V2 hardware. The various ready-to-run and deployable modules serve the purpose of showcasing the different features of the hardware by incorporating and applying the Atinverter library. The following diagram provides a visual representation of the software hierarchy and the available C++ and Arduino .ino files that the user can utilize to enable Atinverter V2 hardware operation. graph LR; %% Node Definitions A(**software**) style A fill:skyblue,stroke:white,stroke-width:2px B(**Blink**) style B fill:skyblue,stroke:white,stroke-width:2px C(**Library**) style C fill:skyblue,stroke:white,stroke-width:2px D(**Main**) style D fill:skyblue,stroke:white,stroke-width:2px E(**PWM_Inverting**) style E fill:skyblue,stroke:white,stroke-width:2px F(**VI_Sensing**) style F fill:skyblue,stroke:white,stroke-width:2px G(**Blink.ino**) style G fill:skyblue,stroke:white,stroke-width:2px H(**Atinverter.cpp**) style H fill:skyblue,stroke:white,stroke-width:2px I(**Atinverter.h**) style I fill:skyblue,stroke:white,stroke-width:2px J(**Main.ino**) style J fill:skyblue,stroke:white,stroke-width:2px K(**50Hz_PWM_Inverter.ino**) style K fill:skyblue,stroke:white,stroke-width:2px L(**60Hz_PWM_Inverter.ino**) style L fill:skyblue,stroke:white,stroke-width:2px M(**Vdc_Sensing.ino**) style M fill:skyblue,stroke:white,stroke-width:2px N(**Idc_Sensing.ino**) style N fill:skyblue,stroke:white,stroke-width:2px O(**Vac_Sensing.ino**) style O fill:skyblue,stroke:white,stroke-width:2px P(**Iac_Sensing.ino**) style P fill:skyblue,stroke:white,stroke-width:2px %% Node Connections A --&gt; B A --&gt; C A --&gt; D A --&gt; E A --&gt; F B --&gt; G C --&gt; H C --&gt; I D --&gt; J E --&gt; K E --&gt; L F --&gt; M F --&gt; N F --&gt; O F --&gt; P %% Change color of arrow heads %%{init: {'themeVariables': {'lineColor': 'white'}}}%% %% Apply color to the arrows %% 0: 1st arrow (A --&gt; B) 1: 2nd arrow (A --&gt; C) 2: 3rd arrow (A --&gt; D) 3: 4th arrow (A --&gt; E) 4: 5th arrow (A --&gt; F) linkStyle 0 stroke:white, stroke-width:3px; linkStyle 1 stroke:white, stroke-width:3px; linkStyle 2 stroke:white, stroke-width:3px; linkStyle 3 stroke:white, stroke-width:3px; linkStyle 4 stroke:white, stroke-width:3px; %% 5: 6th arrow (B --&gt; G) linkStyle 5 stroke:white, stroke-width:3px; %% 6: 7th arrow (C --&gt; H) 7: 8th arrow (C --&gt; I) linkStyle 6 stroke:white, stroke-width:3px; linkStyle 7 stroke:white, stroke-width:3px; %% 8: 9th arrow (D --&gt; J) linkStyle 8 stroke:white, stroke-width:3px; %% 9: 10th arrow (E --&gt; K) 10: 11th arrow (E --&gt; J) linkStyle 9 stroke:white, stroke-width:3px; linkStyle 10 stroke:white, stroke-width:3px; %% 11: 12th arrow (F --&gt; M) 12: 13th arrow (F --&gt; N) 13: 14th arrow (F --&gt; O) 14: 15th arrow (F --&gt; P) linkStyle 11 stroke:white, stroke-width:3px; linkStyle 12 stroke:white, stroke-width:3px; linkStyle 13 stroke:white, stroke-width:3px; linkStyle 14 stroke:white, stroke-width:3px; . Figure X. Atinverter V2 Software Modules and Files . ",
    "url": "/software/a_v2_sw.html#atinverter-v2-software",
    
    "relUrl": "/software/a_v2_sw.html#atinverter-v2-software"
  },"15": {
    "doc": "Atinverter V2 Software",
    "title": "Atinverter V2 Software",
    "content": ". ",
    "url": "/software/a_v2_sw.html",
    
    "relUrl": "/software/a_v2_sw.html"
  },"16": {
    "doc": "AC Current Sensing",
    "title": "AC Current Sensing Hardware",
    "content": ". Sensing the current from the AC output load is conceptually similar to sensing the DC input current, but includes an additional intermediate step. Instead of directly providing analog voltage samples that correspond to a current reading from the TMCS1108 to the ATMEGA328P, the samples are first delivered to the second input channel of the ADC122S021. Figure X. AC Current Sensing Block Diagram . The ADC122S021 offers higher levels of resolution and better sampling performance compared to the ATMEGA328P‚Äôs built-in ADC channels. This improvement is particularly beneficial for monitoring the AC output current signal, which carries greater importance for waveform control and feedback than the DC input current. The control loop feedback, which is to be implemented in future iterations of the board, is fundamentally reliant on an accurate and high-resolution output current sampling mechanism. Ultimately, by leveraging a higher-performance ADC, the system will be better equipped to support real-time control decisions and more precise actuation of the inverter output. To gain more insight into how the algorithm for computing the AC load current is performed using the ADC122S021, please refer to the AC V/I Sensing Library Feature section. ",
    "url": "/hardware/atinverter_v2/ac_curr_sensing_hw.html#ac-current-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/ac_curr_sensing_hw.html#ac-current-sensing-hardware"
  },"17": {
    "doc": "AC Current Sensing",
    "title": "AC Current Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/ac_curr_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/ac_curr_sensing_hw.html"
  },"18": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing Library Feature",
    "content": ". ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#ac-vi-sensing-library-feature",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#ac-vi-sensing-library-feature"
  },"19": {
    "doc": "AC V/I Sensing",
    "title": "üìã Overview",
    "content": "The AC Voltage and Current Sensing feature enables real-time monitoring of the PWM inverter‚Äôs output voltage and current. It leverages the ATMEGA328P‚Äôs SPI peripheral to interface with the ADC122S021 which samples conditioned analog signals. This feature includes methods for configuring the SPI bus, acquiring ADC readings, correcting DC offset, computing RMS values, and setting the sensitivity factor that scales the AC RMS readings. As mentioned in the AC Voltage Sensing hardware section, to achieve AC RMS voltage measurement across the load of the power inverter ($V_{\\mathrm{AC_load}}$), the signal is: . | Transformed from a 12V-48$V_{pk}$ AC signal to a composite signal containing both DC and AC components. | Scaled down to a 2.5V DC, 0-1V AC peak signal (effectively ranges from 1.5V to 3.5V), to maintain compatibility with the ADC122S021 input channels | . Now that this signal is conditioned appropriately for sampling, the next step is properly configure the SPI bus on the ATMEGA328P to interface with the ADC122S021. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-overview",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-overview"
  },"20": {
    "doc": "AC V/I Sensing",
    "title": "üîÑ Outline of SPI Communication",
    "content": "The ATMEGA328P operates as the master/controller and the ADC122S021 as the slave/peripheral. As it is conventional in SPI communication, the ATMEGA328P initiates communication by setting CS low. The communication is conducted in 16 clock pulses of the SCLK frequency, corresponding to two byte data frames. Since SPI inherently is full-duplex, these two data frames are used for: . | Sending control data through MOSI (DIN of ADC122S021) to specify the channel to read from | Receiving conversion data through MISO (DOUT of ADC122S021) | . It should be highlighted that the only useful data for DIN and DOUT are the first 8 most significant bits (MSB) and the last 12 least significant bits (LSB) respectively. The ADC122S021 uses a successive approximation register (SAR) topology with a track-and-hold mechanism. The voltage samples are tracked for the first 4 clock cycles and held for data transmission during the subsequent 12 clock cycles. Once the 12-bit conversion data is received by the ATMEGA328P, the CS line is enabled high to terminate communication with the ADC122S021. The timing diagram of the ADC122S021 provides an insightful visual representation of the SPI communication and reflects the information covered. Figure X. ADC122S021 Operational Timing Diagram . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-outline-of-spi-communication",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-outline-of-spi-communication"
  },"21": {
    "doc": "AC V/I Sensing",
    "title": "‚åö Choosing the Appropriate SPI Clock Source",
    "content": "Ensuring suitable communication with the ADC122S021 relies on providing a clock source from the ATMEGA328P that falls within the allowable frequency range of the device. The clock signal is critical as it maps to the sampling rate of the ADC122S021 which is also constrained to a specific range. The table below summarizes the ranges of allowable clock frequencies and their corresponding sample rates: . Table X. Allowable Clock Frequency and Sampling Rate Ranges for the ADC122S021 . | Notation | Parameter | Range | . | $f_{sclk}$ | Clock Frequency | 0.8MHz - 3.2MHz | . | $f_{s}$ | Sample Rate | 50ksps - 200ksps | . The relationship between the sample rate and the clock frequency can be understood from the following equation: . \\[f_{s} = \\frac{f_{SCLK}}{16}\\] This expression reflects the idea that a complete 12-bit signal conversion requires 16 clock pulses. As a result, the sampling frequency is one-sixteenth of the clock frequency. The clock source delivered to the ADC122S021 is derived from the 16MHz main clock of the ATMEGA328P and is configured using one of several available prescaler options. These prescalers divide the system clock to produce the appropriate SPI clock frequency, as outlined in the table below: . Table X. Available SPI Clock Prescalers and Resulting Frequencies Based on 16‚ÄØMHz System Clock . | Prescaler | Arduino Command | Resulting Frequency | . | 2 | SPI_CLOCK_DIV2 | 8 MHz | . | 4 | SPI_CLOCK_DIV4 | 4 MHz | . | 8 | SPI_CLOCK_DIV8 | 2 MHz | . | 16 | SPI_CLOCK_DIV16 | 1 MHz | . | 32 | SPI_CLOCK_DIV32 | 500 kHz | . | 64 | SPI_CLOCK_DIV64 | 250 kHz | . | 128 | SPI_CLOCK_DIV128 | 125 kHz | . Given that the clock signal is constrained to the range of 0.8MHz - 3.2MHz for the ADC122S021, this means we can choose to either to supply a 1MHz or 2MHz clock signal from the ATMEGA328P. Either option is in theoretically valid, but there are important tradeoffs to consider: . Choosing a higher sampling frequency (2MHz): . | Better resolution | Improved signal to noise ratio (SNR) | Spreading of ADC quantization noise over a broader bandwidth | . Choosing a lower sampling frequency (1MHz): . | Reduced software overhead (fewer clock cycles) | Less memory intensive for MCU | More power efficient | . The Nyquist Sampling Theorem states that to minimally reconstruct an analog signal without aliasing, the sampling frequency $f_{s}$ must be at least 2 times the maximum frequency component $f_{max}$ of the analog signal. This miminum requirement for the sampling rate is also known as the Nyquist Rate. \\[f_{s} \\geq 2 \\times f_{max}\\] Aliasing represents an adverse effect where the sampled waveform loses its characteristic shape and appears as a different frequency. While just marginally satisfying the Nyquist Rate condition may be appropriate in some applications, this does not always guarantee proper resolution and amplitude accuracy of the signal. In practical applications such as sampling sinusoidal signals, it is recommended that $f_{s}$ is at least 5 to 10 times the sinusoidal signal $f_{sinusoid}$. Higher ADC sample rates yield finer resolution in the digitized sinusoidal waveform, whereas lower sampling raters result in a degraded signal in terms of resolution and signal shape. In this design, the ADC122S021 is tasked with sampling the output voltage and current signals of PWM inverter, both of which are 50Hz or 60Hz sinusoidal signals depending on the PWM generation technique. Considering how these signals are far lower in frequency relative to the sampling capabilities of the ADC122S021, a clock rate of 1MHz (pre-scaler 16) was selected. This aims to reduce software overhead and memory load as well as maintain an adequate sampling rate for proper signal digitization. \\[f_{s} = \\frac{1 \\times 10^6Hz}{16} = 62.5kHz\\] \\[\\frac{f_{s}}{f_{max}} = \\frac{62.5 \\times 10^3Hz}{60Hz} ‚âà 1042\\] The sampling frequency is substantially larger than the recommended amount so a high fidelity signal is to be expected. Translating this concept into software, the command below: . SPI.beginTransaction(SPISettings(CLOCK_FREQUENCY, MSBFIRST, SPI_MODE0)); . is used to specify key metrics of the SPI communication protocol. The CLOCK_FREQUENCY is a macro that maps to 1MHz. In addition, most significant bit (MSB) transmission and SPI Mode 0 (CPOL = 0, CPHA = 0) are specified with macros in accordance with ADC122S021 device requirements. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-choosing-the-appropriate-spi-clock-source",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-choosing-the-appropriate-spi-clock-source"
  },"22": {
    "doc": "AC V/I Sensing",
    "title": "üìå Pin Assignments",
    "content": ". Table X. ATMEGA328P Pin Configuration for SPI Communication . | Pin Type | Digital Pin Number | State | . | CS | 10 | OUTPUT | . | MOSI | 11 | OUTPUT | . | MISO | 12 | INPUT | . | SCLK | 13 | OUTPUT | . Configuring all SPI pins on the ATMEGA328P can be performed by using SPI.begin() from the Arduino built-in SPI.h library. Since the SPI.h library is included in the user-defined header file Atinverter.h, no need to include it separately in the module program. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-pin-assignments"
  },"23": {
    "doc": "AC V/I Sensing",
    "title": "üìÇ Header File Definitions",
    "content": "Implementation in Atinverter.h: . #include &lt;SPI.h&gt; // TMCS1108 Current Sensor Parameters #define SENSOR_GAIN_MV_PER_A 400.0f #define MV_TO_V 1000.0f #define VOUT_0A 2.5f // ADC Parameters #define VREF 5.0f #define ADC_122S021_MAX_VALUE 4095.0f #define VAC_ADC_CHANNEL 0x00 #define IAC_ADC_CHANNEL 0x08 #define CLOCK_FREQUENCY 1000000 // --- AC RMS Parameters --- #define MS_PER_SECOND 1000 #define DEFAULT_SENSITIVITY 500.0f #define SENSITIVITY 37.81f // Parameters AC Sensing uint32_t period; float sensitivity = DEFAULT_SENSITIVITY; // AC Voltage and Current Pin Definitions static const int VI_AC_CS_PIN = 10; static const int VI_AC_MOSI_PIN = 11; static const int VI_AC_MISO_PIN = 12; static const int VI_AC_SCLK_PIN = 13; // Methods void setUpSPI(); void setSensitivity(float value); int getADC(uint8_t control_byte); int getZeroPoint(uint8_t control_byte); float getRmsAC(uint8_t loopCount, bool isVac); . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-header-file-definitions",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-header-file-definitions"
  },"24": {
    "doc": "AC V/I Sensing",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-method-descriptions"
  },"25": {
    "doc": "AC V/I Sensing",
    "title": "void setUpSPI()",
    "content": "Purpose: Initializes the SPI interface and configures the relevant pins. Pseudocode: . | Configure CS, MOSI, and SCLK pins to their desired state | . Implementation in Atinverter.cpp: . void Atinverter::setUpSPI() { SPI.begin(); } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#void-setupspi",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#void-setupspi"
  },"26": {
    "doc": "AC V/I Sensing",
    "title": "int getZeroPoint(uint8_t control_byte)",
    "content": "Purpose: Calculates the zero-point (DC offset) value of the ADC readings over a full sampling period. This value is used to remove the DC bias from the AC signal before performing RMS calculations. Parameters: . | control_byte ‚Äì ADC command byte: 0x00 selects channel 1; 0x08 selects channel 2 | . Pseudocode: . | Initialize accumulators and timing | While the elapsed time is less than the period: . | Read the ADC value from the specified control_byte channel | Accumulate the ADC value | Increment the measurement count | . | Compute and return the average (sum divided by the count) | . Implementation in Atinverter.cpp: . int Atinverter::getZeroPoint(uint8_t control_byte) { uint32_t Vsum = 0; uint32_t measurements_count = 0; uint32_t t_start = this-&gt;millis2(); while (this-&gt;millis2() - t_start &lt; period) { Vsum += this-&gt;getADC(control_byte); measurements_count++; } return Vsum / measurements_count; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#int-getzeropointuint8_t-control_byte",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#int-getzeropointuint8_t-control_byte"
  },"27": {
    "doc": "AC V/I Sensing",
    "title": "void setSensitivity(float value)",
    "content": "Purpose: Sets the sensitivity factor used to scale RMS ADC values to real-world signal amplitude. The sensitivity factor is applied in the getRmsAC() method after calculating the RMS value of the ADC samples. It ensures that the returned value reflects the actual physical signal magnitude, not just the ADC voltage level. Pseudocode: . | Take the user-defined sensitivity input. | Store it as the internal sensitivity scaling variable. | . Implementation in Atinverter.cpp: . void Atinverter::setSensitivity(float value) { sensitivity = value; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#void-setsensitivityfloat-value",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#void-setsensitivityfloat-value"
  },"28": {
    "doc": "AC V/I Sensing",
    "title": "int getADC(uint8_t control_byte)",
    "content": "Purpose: Initiates an SPI transaction with the ADC122S021 to retrieve a 12-bit digital conversion result from the specified input channel. Parameters: . | control_byte ‚Äì ADC command byte: 0x00 selects channel 1; 0x08 selects channel 2 | . Pseudocode: . | Pull CS low and configure SPI parameters to begin SPI transmission | Conduct 1st byte transfer . | Send control byte to specify channel | Receive 8 MSB conversion bits (only 4 LSB are significant) | . | Shift first 8 bits received by 8 bits to make that MSB data | Conduct a 2nd byte transfer . | Send dummy byte (0x00) | Receive 8 LSB bits of conversion | . | Combine the 2 received bytes (MSB + LSB) | Mask the lower 12 bits to get valid ADC data | Pull CS high to end transaction | Return 12-bit ADC sample | . Implementation in Atinverter.cpp: . int Atinverter::getADC(uint8_t control_byte) { digitalWrite(VI_AC_CS_PIN, LOW); SPI.beginTransaction(SPISettings(CLOCK_FREQUENCY, MSBFIRST, SPI_MODE0)); uint16_t data = SPI.transfer(control_byte); data &lt;&lt;= 8; data |= SPI.transfer(0x00); digitalWrite(VI_AC_CS_PIN, HIGH); SPI.endTransaction(); data &amp;= 0x0FFF; return data; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#int-getadcuint8_t-control_byte",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#int-getadcuint8_t-control_byte"
  },"29": {
    "doc": "AC V/I Sensing",
    "title": "float getRmsAC(uint8_t loopCount, bool isVac)",
    "content": "Purpose: Calculates the RMS value of either AC voltage or current over multiple user-defined sampling cycles. The value is offset-corrected using the zero-point and scaled using a sensitivity factor to reflect the actual signal amplitude. Parameters: . | loopCount ‚Äì number of sampling cycles to average over for increased accuracy | isVac ‚Äì true to measure AC voltage; false to measure AC current | . Pseudocode: . | Determine the ADC channel based on isVac . | true to use voltage channel, false to use current channel | . | Iterate loopCount times: . | Compute DC offset using getZeroPoint() | Initialize accumulators and timing | While elapsed time is less than the period: | . | Sample ADC | Remove DC offset and square the result | Accumulate the sum and measurement count | Compute RMS value using the root mean square formula: $X_{RMS} = \\sqrt{\\frac{1}{N} \\sum x^2}$ | Scale result using sensitivity to convert to physical units | . | Average all loop results and return the final RMS value | . Implementation in Atinverter.cpp: . float Atinverter::getRmsAC(uint8_t loopCount, bool isVac) { uint8_t control_byte; if (isVac){ control_byte = VAC_ADC_CHANNEL; } else{ control_byte = IAC_ADC_CHANNEL; } double readingVoltage = 0.0f; for (uint8_t i = 0; i &lt; loopCount; i++) { int zeroPoint = this-&gt;getZeroPoint(control_byte); int32_t Vnow = 0; uint32_t Vsum = 0; uint32_t measurements_count = 0; uint32_t t_start = this-&gt;millis2(); while (this-&gt;millis2() - t_start &lt; period) { Vnow = this-&gt;getADC(control_byte) - zeroPoint; Vsum += (Vnow * Vnow); measurements_count++; } readingVoltage += sqrt(Vsum / measurements_count) / ADC_122S021_MAX_VALUE * VREF * sensitivity; } return readingVoltage / loopCount; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#float-getrmsacuint8_t-loopcount-bool-isvac",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#float-getrmsacuint8_t-loopcount-bool-isvac"
  },"30": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing",
    "content": ". ",
    "url": "/software/library/features/ac_vi_sensing_feature.html",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html"
  },"31": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing Program Modules",
    "content": ". Purpose: These two standalone programs (Vac_Sensing.ino and Iac_Sensing.ino) demonstrate how to use the Atinverter library‚Äôs AC sensing features to measure either the RMS voltage or RMS current output of the PWM inverter. Both modules validate correct SPI communication with the ADC122S021, PWM generation for inverter operation, signal processing using the root mean square (RMS) method, and employ the Timer 2 based delaying feature. ",
    "url": "/software/modules/ac_vi_sensing_module.html#ac-vi-sensing-program-modules",
    
    "relUrl": "/software/modules/ac_vi_sensing_module.html#ac-vi-sensing-program-modules"
  },"32": {
    "doc": "AC V/I Sensing",
    "title": "Vac_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance | Initialize the serial monitor for displaying AC voltage readings | Set sensitivity factor that scales the AC RMS readings | Set up SPI interface and associated pins | Begin PWM operation at a specified frequency of 50Hz or 60Hz | Initialize Timer 2 for time-based delay functionality | Continuously read the averaged output AC voltage | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" #define LOOP_RUNS 20 Atinverter atinverter; void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Output AC Voltage Sensing.\")); atinverter.setSensitivity(SENSITIVITY); atinverter.setUpSPI(); atinverter.startPWM(60); atinverter.initTimer2Delay(); } void loop() { float Vac_RMS = atinverter.getRmsAC(true, LOOP_RUNS); Serial.print(F(\"Vac(RMS): \")); Serial.print(Vac_RMS); Serial.println(\"V\"); atinverter.delay2(2000); } . ",
    "url": "/software/modules/ac_vi_sensing_module.html#vac_sensingino",
    
    "relUrl": "/software/modules/ac_vi_sensing_module.html#vac_sensingino"
  },"33": {
    "doc": "AC V/I Sensing",
    "title": "Iac_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance | Initialize the serial monitor for displaying AC current readings | Set sensitivity factor that scales the AC RMS readings | Set up SPI interface and associated pins | Begin PWM operation at a specified frequency of 50Hz or 60Hz | Configure Timer 2 registers to enable delaying using delay2 method | Continuously read the averaged output AC current | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" #define LOOP_RUNS 20 Atinverter atinverter; void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Output AC Voltage Sensing.\")); atinverter.setSensitivity(SENSITIVITY); atinverter.startPWM(60); atinverter.setUpSPI(); atinverter.initTimer2Delay(); } void loop() { float Iac_RMS = atinverter.getRmsAC(false, LOOP_RUNS); Serial.print(F(\"Iac(RMS): \")); Serial.print(Iac_RMS); Serial.println(\"A\"); atinverter.delay2(2000); } . ",
    "url": "/software/modules/ac_vi_sensing_module.html#iac_sensingino",
    
    "relUrl": "/software/modules/ac_vi_sensing_module.html#iac_sensingino"
  },"34": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing",
    "content": " ",
    "url": "/software/modules/ac_vi_sensing_module.html",
    
    "relUrl": "/software/modules/ac_vi_sensing_module.html"
  },"35": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing Hardware",
    "content": ". To achieve the sensing of the AC voltage at the output of the power inverter, the approach is more involved than the DC voltage sensing methodology. Not only does a step down mechanism need to be implemented to provide a low power sensed signal to a processing device, but also a method to handle or correct for the the bipolar nature of the AC wave, namely the negative swing. More specifically, the AC voltage sensing network needs to be able to scale a 24V - $96V_{pkpk}$ signal to 0-5V signal in order to be compatible with the ADC122S021, which is used for output voltage and current sampling. The ADC122S021 serves as the intermediary between the ATMEGA328P and the AC sensed signal. It samples the output produced by the AC voltage sensing network and transmits the data to the ATMEGA328P via SPI communication. The ATMEGA328P receives the sensed data by requesting channel 1 of the ADC122S021 and uses it to compute the RMS reading of the voltage. Figure X. AC Voltage Sensing Block Diagram . This section covers the hardware implementation for the AC sensing framework as illustrated above. To learn more about how the voltage RMS computation is performed and other key considerations for the software design, see the section AC V/I Sensing Library Feature. ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-hardware"
  },"36": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing Network",
    "content": ". Figure X. AC Voltage Sensing Network . The design is comprised of two main stages: . | ZMPT101B Transformer . | Voltage step-down using 1:1 isolation transformer | Well known and documented for projects that interface with Arduino/ESP/RaspberryPi devices | . | Signal Conditioning and Amplification . | A cascaded pair of inverting op-amp configurations to amplify the low-voltage sensed signal | Tunable gain set by a potentiometer that aims to reduce potential saturation or improve resolution at AC sensing output | Active low-pass filter attenuates high frequecy noise and improve signal integrity | . | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-network",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-network"
  },"37": {
    "doc": "AC Voltage Sensing",
    "title": "ZMPT101B Transformer",
    "content": "The first stage is based on the ZMPT101B current transformer. It is a 1:1, 1000V, 2mA rated transformer. For a more thorough documentation of the component, please review the ZMPT101B datasheet. The input to output voltage relation describing the transformer operation is stated in Figure II of the datasheet: . \\[U_{2} = \\frac{U_{1}}{R'} \\times R\\] where: . | $U_1$ is the input voltage | $U_2$ is the output voltage | $R‚Äô$ is the current limiting resistor | $R$ is the voltage sampling resistor | . In efforts to maintain consistency with the previous AC Voltage Circuit diagram, we will denote $U_1$, $U_2$, $R‚Äô$, $R$ as $V_{\\mathrm{AC_in}}$, $V_{\\mathrm{AC_samp}}$, $R_{lim}$, $R_{samp}$ respectively. Therefore, the newly denoted equation is . \\[V_{\\mathrm{AC_samp}} = \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#zmpt101b-transformer",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#zmpt101b-transformer"
  },"38": {
    "doc": "AC Voltage Sensing",
    "title": "üî¢ Calculating $R_{lim}$",
    "content": "To achieve higher levels of Signal-to-Noise Ratio (SNR), better ADC range, and noise immunity, a current limiting resistor $R_{lim}$ should be selected such that the magnitude is near the rated current but not exceeding. Choosing a current limiting resistor is based on the highest expected voltage that will be delivered to the input primary side of the transformer. Recalling that the maximum peak voltage for the power inverter is 48V, and considering that the transformer has a rated current of 2mA, a max current value of 1.5mA is chosen. This ensures that $V_{\\mathrm{AC_in}}$ is maximized in signal strength to improve resolution, but also provides buffer from operating the part at rated conditions. \\[R_{lim} = \\frac{V_{\\mathrm{AC_in}}}{I_{\\mathrm{AC_in}}}\\] \\[R_{lim} = \\frac{48V}{1.5mA} = 32k\\Omega\\] . | Choose $33k\\Omega$ based on standard resistor values | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_lim",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_lim"
  },"39": {
    "doc": "AC Voltage Sensing",
    "title": "üî¢ Calculating $R_{samp}$",
    "content": "The sampling resistance linearly influences the transformer AC voltage output as per the equation in Figure II. By rearranging the ZMPT101B expression, this renders the following equation usable for solving the sampling resistor in a passive configuration where no amplification is present. \\[V_{\\mathrm{AC_samp}} = \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] \\[R_{samp} = \\frac{V_{\\mathrm{AC_samp}}}{V_{\\mathrm{AC_in}}} \\times R_{lim}\\] However, this expression is not directly applicable since it makes use of an active configuration. Nonetheless, it can be adapted to suit the needs of the current design as detailed in the next section. ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_samp",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_samp"
  },"40": {
    "doc": "AC Voltage Sensing",
    "title": "Signal Conditioning and Amplification",
    "content": "The second stage of the AC Voltage Sensing Network is a combination of two inverting amplification phases that serve the purpose of amplifying the low voltage signal produced across the sampling resistor. Each level provides an amplification factor of 10, yielding a net gain of 100. To develop a transfer function that accounts for this two op-amp amplification chain in the AC voltage sensing network, this gain stage can be modeled by a variable $G_{amp}$. This net gain is also equivalent to the product of the two intermediate gains $G_{1} \\times G_{2}$. The AC voltage from output to input then can be described as: . \\[V_{\\mathrm{ACsense}} = G_{amp} \\times \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] It is important to note that $V_{\\mathrm{ACsense}}$ refers to the desired AC magnitude that will be provided to the ADC122S021 after the two op amp chain whereas $V_{\\mathrm{ACsamp}}$ is the AC magnitude at the secondary of the transformer. The amplification phases are also designed to attenuate high frequency noise, as they are based on the active low pass filter topology. This is necessary because although the output of the transformer is being amplified in two segments, the noise present at the op-amp inputs can also amplified. It is beneficial to have this embedded into the design since $V_{\\mathrm{ACsense}}$ needs to be a clean waveform for accurate readings from the ADC122S021. The cutoff frequency of this 1st order low-pass filter can be calculated using the following formula: . \\[f_{c} = \\frac{1}{2\\pi \\times C_{lp} \\times R_{fb}}\\] Another key feature of the AC Voltage Sensing Network is the potentiometer, $R_{tune}$ as it also impacts the magnitude of $V_{\\mathrm{ACsense}}$. Since the potentiometer functions as a voltage divider, it can be modeled by introducing two resistors: $R_{tune1}$, the resistor in series with the signal path, and $R_{tune2}$, the resistor connected to ground. Therefore, the divider ratio is: . \\[G_{tune} = \\frac{R_{tune1}}{R_{tune1}+ R_{tune2}}\\] Since the divider ratio is effectively a gain constant between the first and second op amp chain, both of which are linearly combined, the specific placement of this term has no effect on the $V_{\\mathrm{ACsense}}$ computation. \\[V_{\\mathrm{ACsense}} = G_{amp} \\times \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp} \\times G_{tune}\\] To obtain the final sampling resistor equation that, we can isolate for the sampling resistor: . \\[R_{samp} = \\frac{V_{\\mathrm{ACsense}}}{V_{\\mathrm{AC_in}} \\times G_{amp} \\times G_{tune}} \\times R_{lim}\\] The AC portion of the $V_{\\mathrm{ACsense}}$ signal must remain within the saturation limits of the LM358 op-amp due to resulting amplified signal being centered around a 2.5V DC offset, which is caused by the $R_{bias}$ resistors. Since the LM358 op amp saturates at about 1.5V from the supply voltage (i.e. 5V - 1.5V = 3.5V), then the maximum permissible swing is $V_{\\mathrm{ACsense}} = 1V_{pk}$. The worst case scenario for potential saturation occurs when the potentiometer provides no gain attenuation (i.e $G_{tune} = 1$), resulting in an amplification of $G_{amp}$ = 100 applied to $V_{\\mathrm{ACsamp}}$. Using this case to calculate the sampling resistor is performed for both ends of the inverter range. \\(V_{\\mathrm{AC_in}}\\) = 12V: . \\[R_{samp} = \\frac{1}{12 \\times 100 \\times 1} \\times 33k = 27.5\\Omega\\] \\(V_{\\mathrm{AC_in}}\\) = 48V: . \\[R_{samp} = \\frac{1}{48 \\times 100 \\times 1} \\times 33k = 6.87\\Omega\\] . | A $6.8\\Omega$ resistor was selected based on standard resistor values, as this accommodates for both 12V and 48V $V_{\\mathrm{AC_in}}$. A smaller resistance results in a smaller voltage drop, which is subsequently amplified less‚Äîmaking the output signal less prone to op-amp saturation. The effective amplitude of the sensed signal can then be increased by reducing $R_{tune}$, allowing the op-amp output to span a larger portion of its available swing without exceeding its limits. This maximizes the effective use of the ADC‚Äôs input range, making the signal easier to sample accurately. | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#signal-conditioning-and-amplification",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#signal-conditioning-and-amplification"
  },"41": {
    "doc": "AC Voltage Sensing",
    "title": "LTSpice Simulation",
    "content": "The AC voltage sensing topology was simulated using LTSpice, a free SPICE-based software with schematic capture and waveform viewer capabilities. Component types and values were employed to most closely resemble the actual circuit implementation. The AC source $V_{ac_{in}}$ represents the differential voltage across the power inverter load, which ranges from $12V_{pk}$ to $48V_{pk}$. A 5V logic power supply $V_{cc}$ is used to power the op-amps as well as the DC bias resistor networks. Two minor modeling adjustments were made to align the simulation with the physical circuit: . | Op-Amp Substitution: The OP07 was used in place of the LM358 to reflect amplification behavior with similar electrical characteristics. | Potentiometer Emulation: The adjustable gain stage was modeled using two adjustable resistors, $R_{tune1}$ and $R_{tune2}$, to mimic the behavior of a tunable potentiometer. | . The implementation of the simulation circuit is displayed below: . Figure X. AC Voltage Sensing Network Simulation Circuit . The goal of the simulations is to observe how the output sensed voltage, $V_{\\mathrm{ACsense}}$, is influenced by the input AC voltage amplitude and the potentiometer tunable gain. This signal is subsequently delivered to the ADC122S021 for sampling. More specifically, the expected waveform consists of a composite DC and AC signal: a 2.5V DC offset determined by the bias resistor network, and an AC swing that corresponds to a scaled version of the input AC signal amplitude. A key factor in determining how accurately the external ADC samples the sensed output voltage is its resolution, defined by the number of quantization levels‚Äîalso referred to as ADC steps. These steps represent the discrete voltage increments that the ADC can detect. The higher the AC component of $V_{\\mathrm{ACsense}}$, the more ADC levels can be captured which improves the effective resolution of the signal acquired. The resolution for an n-bit ADC can be computed using the expression: . \\[\\Delta_{ADC} = \\frac{V_{ref}}{2^n}\\] For this design, the ADC122S021 is powered using a 5V logic supply, therefore: . \\[\\Delta_{ADC} = \\frac{5V}{2^{12}} \\approx 1.22mV/step\\] This means that the ADC122S021 detects voltage increments of 1.22mV which is a fixed hardware specification of the device. Additionally, the step size is closely related to the concept of measurement resolution, which refers to how finely the signal can be detected based on its amplitude and can be calculated as follows: . \\[\\Delta_{meas} (\\%) = \\frac{\\Delta_{ADC}}{V_{signal_{pkpk}}} \\times 100\\] This metric can also be interpreted as the relative quantization error with respect to the signal‚Äôs amplitude. Essentially, a larger value signifies that the ADC step spans a larger fraction of the signal, thereby reducing the effective resolution of the measurement. To develop an intuition for how the AC swing of the $V_{\\mathrm{ACsense}}$ affects the measurement resolution and to verify that the signal does not saturate from op amp amplification, a series of six simulation were conducted under various conditions. Case #1: ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.1$ $(R_{tune1} = 90k\\Omega$, $R_{tune2} = 10k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.1$ . | No saturation observed; output AC swing ranges from 2.48V to 2.51V | Measured peak-to-peak signal amplitude: 26.14mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{26.14mV} \\times 100 = 4.66\\% %\\] . | Acceptable but coarse measurement resolution; one ADC step accounts for 4.66% of the signal amplitude, expected given the low tunable gain. | . Case #2: ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.5$ $(R_{tune1} = 50k\\Omega$, $R_{tune2} = 50k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.5$ . | No saturation observed; output AC swing ranges from 2.46V to 2.53V | Measured peak-to-peak signal amplitude: 71.65mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{71.65mV} \\times 100 = 1.70\\% %\\] . | Improved resolution; each ADC step contributes 1.70% to the signal span, appropriate for moderate tunable gain setting. | . Case #3: ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.9$ $(R_{tune1} = 10k\\Omega$, $R_{tune2} = 90k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 12V$ and $G_{tune} = 0.9$ . | No saturation observed; output AC swing ranges from 2.38V to 2.61V | Measured peak-to-peak signal amplitude: 235.27mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{235.27mV} \\times 100 = 0.52\\% %\\] . | Excellent measurement resolution; one ADC step corresponds to only 0.52% of the signal amplitude, expected with higher tunable gain setting. | . Case #4: ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.1$ $(R_{tune1} = 90k\\Omega$, $R_{tune2} = 10k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.1$ . | No saturation observed; output AC swing ranges from 2.44V to 2.55V | Measured peak-to-peak signal amplitude: 104.69mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{104.69mV} \\times 100 = 1.17\\% %\\] . | Moderate measurement resolution; an ADC step contributes to about 1.17% of the signal amplitude, appropriate with lower tunable gain setting. | . Case #5: ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.5$ $(R_{tune1} = 50k\\Omega$, $R_{tune2} = 50k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.5$ . | No saturation observed; output AC swing ranges from 2.35V to 2.64V | Measured peak-to-peak signal amplitude: 286.38mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{286.38mV} \\times 100 = 0.43\\% %\\] . | Excellent measurement resolution; an ADC step represents about 0.43% of the signal amplitude using with midpoint tunable gain setting. | . Case #6: ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.9$ $(R_{tune1} = 10k\\Omega$, $R_{tune2} = 90k\\Omega)$ . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.9$ . | No saturation observed; output AC swing ranges from 2.03V to 2.97V | Measured peak-to-peak signal amplitude: 942.93mV | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{942.93mV} \\times 100 = 0.13\\% %\\] . | Superior measurement resolution; an ADC step represents about only a 0.13% of the signal amplitude using with higher tunable gain setting. | . Case #7: ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.99$ $(R_{tune1} = 1k\\Omega$, $R_{tune2} = 99k\\Omega)$ . | This special case is considered to ensure that the output does not saturate even in the most extreme cases of the potentiometer setting where the tunable gain is significantly high | . Figure X. AC Voltage Sensing Simulation Plot, ${V_{\\mathrm{AC_in}}} = 48V$ and $G_{tune} = 0.99$ . | No saturation observed, but close to theoretical 3.5V saturation point; output AC swing ranges from 1.63V to 3.38V | Measured peak-to-peak signal amplitude: 1.75V | . \\[\\Delta_{meas} (\\%) = \\frac{1.22mV/step}{1.75V} \\times 100 = 0.07\\% %\\] . | Superior measurement resolution; an ADC step represents about only a 0.07% of the signal amplitude using with highest effective tunable gain setting. | . The simulations overall provide an understanding of the relationship between the output sensed voltage signal amplitude with that of the measurement resolution and confirm that the AC voltage sensing network is properly designed such that no saturation occurs at the output. ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ltspice-simulation",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ltspice-simulation"
  },"42": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html"
  },"43": {
    "doc": "Blink",
    "title": "Blink Library Feature",
    "content": ". ",
    "url": "/software/library/features/blink_feature.html#blink-library-feature",
    
    "relUrl": "/software/library/features/blink_feature.html#blink-library-feature"
  },"44": {
    "doc": "Blink",
    "title": "üìã Overview",
    "content": "The Blink feature abstracts low-level pin operations for LED control functionality within the Atinverter library. It includes methods for setting up GPIO pins as outputs, controlling individual LEDs, and cycling through multiple LEDs in a predefined sequence. ",
    "url": "/software/library/features/blink_feature.html#-overview",
    
    "relUrl": "/software/library/features/blink_feature.html#-overview"
  },"45": {
    "doc": "Blink",
    "title": "üìå Pin Assignments",
    "content": ". Table X. ATMEGA328P Pin Configuration for LED Control . | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | Red LED 1 | LED1R_PIN | 2 | OUTPUT | . | Green LED 1 | LED1G_PIN | 3 | OUTPUT | . | Red LED 2 | LED2R_PIN | 4 | OUTPUT | . | Green LED 2 | LED2G_PIN | 7 | OUTPUT | . ",
    "url": "/software/library/features/blink_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/blink_feature.html#-pin-assignments"
  },"46": {
    "doc": "Blink",
    "title": "üìÇ Header File Definitions",
    "content": "Implementation in Atinverter.h: . // LED Pin Definitions static const int LED1R_PIN = 2; static const int LED1G_PIN = 3; static const int LED2R_PIN = 4; static const int LED2G_PIN = 7; // Methods void setUpLEDs(); void set1LED(int LED, int state); void cycleLEDs(int t_delay); . ",
    "url": "/software/library/features/blink_feature.html#-header-file-definitions",
    
    "relUrl": "/software/library/features/blink_feature.html#-header-file-definitions"
  },"47": {
    "doc": "Blink",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/blink_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/blink_feature.html#-method-descriptions"
  },"48": {
    "doc": "Blink",
    "title": "void setUpLEDs()",
    "content": "Purpose: Configures all LED pins as outputs. Pseudocode: . | Configure the state of all 4 LED pins as outputs for driving. | . Implementation in Atinverter.cpp: . void Atinverter::setUpLEDs() { pinMode(LED1R_PIN, OUTPUT); pinMode(LED1G_PIN, OUTPUT); pinMode(LED2R_PIN, OUTPUT); pinMode(LED2G_PIN, OUTPUT); } . ",
    "url": "/software/library/features/blink_feature.html#void-setupleds",
    
    "relUrl": "/software/library/features/blink_feature.html#void-setupleds"
  },"49": {
    "doc": "Blink",
    "title": "void set1LED(int LED, int state)",
    "content": "Purpose: Sets a user-selected LED pin as on or off. Pseudocode: . | Sets a user-selected LED pin as on (HIGH) or off (LOW). | . Implementation in Atinverter.cpp: . void Atinverter::set1LED(int LED, int state) { digitalWrite(LED, state); } . ",
    "url": "/software/library/features/blink_feature.html#void-set1ledint-led-int-state",
    
    "relUrl": "/software/library/features/blink_feature.html#void-set1ledint-led-int-state"
  },"50": {
    "doc": "Blink",
    "title": "void cycleLEDs(int t_delay)",
    "content": "Purpose: Sequentially cycles through four LEDs, turning each on and off with a delay. Pseudocode: . | Turns on each LED in order with a delay in between in milliseconds | Turns off each LED in reverse order with a delay in between in milliseconds | . Implementation in Atinverter.cpp: . void Atinverter::cycleLEDs(int t_delay) { digitalWrite(LED1G_PIN, HIGH); delay(t_delay); digitalWrite(LED1R_PIN, HIGH); delay(t_delay); digitalWrite(LED2G_PIN, HIGH); delay(t_delay); digitalWrite(LED2R_PIN, HIGH); delay(t_delay); digitalWrite(LED2R_PIN, LOW); delay(t_delay); digitalWrite(LED2G_PIN, LOW); delay(t_delay); digitalWrite(LED1R_PIN, LOW); delay(t_delay); digitalWrite(LED1G_PIN, LOW); delay(t_delay); } . ",
    "url": "/software/library/features/blink_feature.html#void-cycleledsint-t_delay",
    
    "relUrl": "/software/library/features/blink_feature.html#void-cycleledsint-t_delay"
  },"51": {
    "doc": "Blink",
    "title": "Blink",
    "content": " ",
    "url": "/software/library/features/blink_feature.html",
    
    "relUrl": "/software/library/features/blink_feature.html"
  },"52": {
    "doc": "Blink",
    "title": "Blink Program Module",
    "content": ". Purpose: This program demonstrates how to utilize the Atinverter library‚Äôs LED control features in a standalone application. This module is useful for confirming the operational state of the microcontroller, hardware connections, and library integration. ",
    "url": "/software/modules/blink_module.html#blink-program-module",
    
    "relUrl": "/software/modules/blink_module.html#blink-program-module"
  },"53": {
    "doc": "Blink",
    "title": "Blink.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance | Set up the period of time for delaying LED operations | Set the GPIO pins for LEDs as outputs | Turn on LED 1 | Turn on LED 2 | Wait for the defined period | Turn off LED 1 | Turn off LED 2 | Wait for the defined period | Cycle through LEDs with delay | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; int PERIOD = 1000; void setup() { atinverter.setUpLEDs(); } void loop() { atinverter.set1LED(atinverter.LED1R_PIN, HIGH); atinverter.set1LED(atinverter.LED2G_PIN, HIGH); delay(PERIOD); atinverter.set1LED(atinverter.LED1R_PIN, LOW); atinverter.set1LED(atinverter.LED2G_PIN, LOW); delay(PERIOD); atinverter.cycleLEDs(PERIOD); } . ",
    "url": "/software/modules/blink_module.html#blinkino",
    
    "relUrl": "/software/modules/blink_module.html#blinkino"
  },"54": {
    "doc": "Blink",
    "title": "Blink",
    "content": " ",
    "url": "/software/modules/blink_module.html",
    
    "relUrl": "/software/modules/blink_module.html"
  },"55": {
    "doc": "Boost Converter",
    "title": "Boost Converter Hardware",
    "content": ". The boost converter network is used to provide the necessary gate drive voltage to the MOSFETs of the H-bridge network, ensuring they are fully enhanced switches to minimize conduction losses. The 5V logic supply ($V_{cc}$) is stepped up to 12V, and is delivered to the IR2302 gate drivers. As a result, all PWM generation signals at the control input are now effectively level shifted to 12V. The specific electrical switches utilized for this design are the IRFB4020PBF MOSFETs, which have a device threshold voltage ranging from 3V - 4.9V according to the IRFB4020PBF datasheet. This implies that driving them with standard 5V logic is not suitable, as this gate bias is only slightly above the threshold and may result in the MOSFETs operating in the saturation (active) region, where they behave more like current amplifiers rather than fully enhanced switches. To ensure efficient switching with minimal conduction losses, the MOSFETs must be driven into the ohmic (triode) region. A key parameter that reflects the conduction efficiency of a MOSFET is the Drain-to-Source On-Resistance ($R_{DS(on)}$) which is directly influenced by the Gate-to-Source Voltage $V_{GS}$. Figure X. IRFB4020PBF On-Resistance vs. Gate Voltage . As per the illustrated figure from the IRFB4020PBF datasheet, operating the MOSFET with a gate voltage of 5V results in an unacceptably high $R_{DS(on)}$ value exceeding $300m\\Omega$, leading to excessive conduction losses. In contrast, a $V_{GS}$ of 12V reduces the $R_{DS(on)}$ to just about $80m\\Omega$ which aligns with the design objective of having efficient, low-loss switching. ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#boost-converter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#boost-converter-hardware"
  },"56": {
    "doc": "Boost Converter",
    "title": "WEBENCH Design",
    "content": "The design of the boost converter was developed using Texas Instrument‚Äôs free, online WEBENCH Power Design tool which generate a complete and customizable power converter depending on user criteria. The TLV61046ADBVR boost converter IC was selected, and the finalized design is accessible for review and customization via Texas Instruments‚Äô WEBENCH interface. The five criteria provided to the WEBENCH interface for the design are: . Figure X. Boost Converter WEBENCH Criteria . As observed from the figure, $V_{in}$ and $V_{out}$ is explicitly defined based on voltage requirements. $I_{outMax} = 0.010A$ is selected based on the output load current described in the next section. Given the low-current application and the absence of high-temperature environmental conditions, a conservative thermal margin of 5¬∞C is applied, resulting in a nominal maximum ambient temperature of 30¬∞C. Once these parameters are provided to the WEBENCH interface, the following boost converter schematic is generated: . Figure X. TLV61046ADBVR Boost Converter Schematic . ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#webench-design",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#webench-design"
  },"57": {
    "doc": "Boost Converter",
    "title": "WEBENCH Simulation",
    "content": "One convenient feature of the WEBENCH Power Designer interface is that it automatically calculates a wide range of performance metrics and displays them within the ‚ÄúOperating Values‚Äù window. These metrics are organized into categories such as System Information, Inductor, Power, and others. A few key operating values and diagnostic plots relevant to this design are shown below: . Figure X. Boost Converter Efficiency (Œ∑) vs. Output Current ($I_{out}$) . Figure X. Boost Converter Output Power ($P_{out}$) vs. Output Current ($I_{out}$) . Figure X. Boost Converter Output Voltage Ripple ($V_{outpp}$) vs. Output Current ($I_{out}$) . Figure X. Boost Converter Inductor Current Ripple ($I_{Lpp}$) vs. Output Current ($I_{out}$) . Table X. Performance Metrics for TLV61046ADBVR Boost Converter Design . | Name | Value | Category | Description | . | Vout | 12 V | System Information | Operational Output Voltage | . | Cout IRMS | 38.15 mA | Capacitor | Output capacitor RMS ripple current | . | Cout Pd | 727.79 nW | Capacitor | Output capacitor power dissipation | . | Efficiency | 85.8% | System Information | Steady state efficiency | . | Frequency | 197.1 kHz | System Information | Switching frequency | . | L Ipp | 102.95 mA | Inductor | Peak-to-peak inductor ripple current | . | L Pd | 1.57 mW | Power | Inductor power dissipation | . | Pout | 120 mW | System Information | Total output power | . | Mode | DCM | System Information | Conduction Mode | . | Vout p-p | 72.88 mV | System Information | Peak-to-peak output ripple voltage | . | Duty Cycle | 59.57% | System Information | Duty cycle | . | Total Pd | 19.87 mW | Power | Total Power Dissipation | . | Vin | 5 V | System Information | Vin operating point | . | Cin Pd | 2.15 ¬µW | Power | Input capacitor power dissipation | . | Cout Pd | 727.79 nW | Power | Output capacitor power dissipation | . | IC Pd | 18.29 mW | Power | IC power dissipation | . | Vout Actual | 11.91 V | System Information | Vout Actual calculated based on selected voltage divider resistors | . ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#webench-simulation",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#webench-simulation"
  },"58": {
    "doc": "Boost Converter",
    "title": "Output Load Current Requirement",
    "content": "The boost converter‚Äôs intended operation is to only drive two IR2302 gate drivers. Thus, the current drawn by both gate drivers defined the total output load current of the converter. The current consumption of a gate driver comprises both static and dynamic current components. According to the the IR2302 datasheet, the maximum quiescent from the $V_{cc}$ supply which also describes the static current of a gate driver is: . \\[I_{static} = I_{QCC} = 1.6mA\\] Since the power inverter network integrates two gate drivers, this results in a total static current of: . $$I_{static(total)} = 2 \\times I_{static}‚Äã . \\[I_{static(total)} = 2 \\times I_{static} = 3.2mA\\] The dynamic current is a characteristic of the MOSFET‚Äôs total gate charge and its switching frequency: . \\[I_{dynamic}‚Äã = Q_{g} ‚Äã\\times f_{sw}\\] Recalling that the PWM generation frequency is 31,372Hz and the maximum total IRFB4020PBF gate charge is 29nC, the dynamic current is: . \\[I_{dynamic}‚Äã = 29nC ‚Äã\\times 31,372Hz = 0.91mA\\] Considering that the power inverter topology consists of 4 MOSFETs, but only two are actively switching at any given time, the total dynamic current is: . \\[I_{dynamic(total)} =‚Äã 2 \\times I_{dynamic}\\] \\[I_{dynamic(total)} =‚Äã 2 \\times 0.91‚Äã = 1.82mA\\] The total output load current for the boost converter to source is: . \\[I_{out}‚Äã = I_{static(total)} ‚Äã+ I_{dynamic(total)}\\] \\[I_{out}‚Äã = 3.2mA ‚Äã+ 1.82mA = 5.02mA\\] Although the selected load current for the WEBENCH boost converter design is selected as 10mA, this provides a comfortable margin to ensure sufficient current delivery to the IR2302 gate drivers, while also designing close to ideal component operating values. ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#output-load-current-requirement",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#output-load-current-requirement"
  },"59": {
    "doc": "Boost Converter",
    "title": "Setting the Output Voltage",
    "content": "The output voltage of the boost converter can be programmed using a resistor divider network connected to the feedback (FB) pin of the TLV61046ADBVR IC. The relationship between the output voltage and the resistor values is given by: . \\[R_{1} = \\left( \\frac{V_{OUT}}{V_{REF}} - 1 \\right) \\times R_{2}\\] To convert to an output voltage of 12V with an internal reference voltage of 795mV, $R_{2}$ is chosen such that a value for $R_{1}$ can be computed: . | $V_{OUT} = 12V$ | $V_{REF} = 795mV$ | $R_{2} = 71.5k\\Omega$ | . \\[R_{1} = \\left( \\frac{12V}{795mV} - 1 \\right) \\times 71.5k\\Omega \\approx 1M\\Omega\\] Thus, $R_{1} = 1M\\Omega$ is selected to achieve the desired 12‚ÄØV output. ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#setting-the-output-voltage",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#setting-the-output-voltage"
  },"60": {
    "doc": "Boost Converter",
    "title": "Boost Converter",
    "content": ". ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html"
  },"61": {
    "doc": "Buck Converter",
    "title": "Buck Converter Hardware",
    "content": ". The buck converter network is main power source that supplies power to most of the Atinverter V2 chips. Specifically, it delivers power to these devices: . | ATMEGA328P | Two TMCS1108A4BQDR (for DC and AC Current Sensing) | LM358N and Two Bias Resistor Networks (for AC Voltage Sensing) | SN74LVC1G32DBVR (for Overvoltage and Reset Protection) | ADC122S021CIMM (for AC V/I Sampling) | Four pull up and 1 bias resistor network (Resistor Arrays, I2C Level Shifter, and FTDI to USB Connector) | . The buck converter chosen is . ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#buck-converter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#buck-converter-hardware"
  },"62": {
    "doc": "Buck Converter",
    "title": "Determining the DC/DC Converter Output Current Needed",
    "content": "Requirements . | Input Voltage: 12V-48V | Output Voltage: 5V | . ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-dcdc-converter-output-current-needed",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-dcdc-converter-output-current-needed"
  },"63": {
    "doc": "Buck Converter",
    "title": "Determining the Required Input Current and PCB Trace Thickness for Switching Converters",
    "content": "Chip parameters . | Chip of Interest: R-78HE-0.3 | DC-DC switching converter, not linear regulator | Input Voltage Range: 6.5V - 48V | Output Voltage: 5V | Output Current: Up to 300mA | Efficiency: Up to 83% | . Power Conversion Equations . (1) \\(P_{\\text{out}} = P_{\\text{in}} + P_{\\text{losses}}\\) (2) \\(Efficiency = \\frac{P_{\\text{out}}}{P_{\\text{in}}}\\) (3) \\(P_{\\text{in}}= V_{\\text{in}} \\times I_{\\text{in}}\\) (4) \\(P_{\\text{out}}= V_{\\text{out}} \\times I_{\\text{out}}\\) . | Plugging in equation (3) into (2) and isolating for \\(I_{\\text{in}}\\) results in: | . \\[I_{\\text{in}} = \\frac{P_{\\text{out}}}{V_{\\text{in}} \\times \\text{Efficiency}}\\] Finding the Maximum Input Current . | Known: \\(V_{\\text{out_max}} = 5V, I_{\\text{out_max}} = 300mA\\) \\(P_{\\text{out_max}} = 5 \\times 300m = 1.5W\\) . | Two cases are considered since the efficiency of the converter changes with the input voltage. \\(V_{\\text{in_max}} = 72\\), Efficiency = 72% \\(I_{\\text{in}} = \\frac{1.5W}{72 \\times \\text{0.72}} = 0.029A\\) \\(V_{\\text{in_min}} = 6.5\\), Efficiency = 83% \\(I_{\\text{in}} = \\frac{1.5W}{6.5 \\times \\text{83}} = 0.278A\\) . | Therefore, the maximum input current is 278mA. This is consistent with the inverse relationship between voltage and current in a DC-DC converter. Although the input current (278mA) is lower than the output current (300mA), the input voltage (6.5V) is higher than the output voltage (5V). This behavior is typical of switching converters, which take advantage of the complementary relationship between input and output voltage and current. | However, to be conservative, let‚Äôs say the chip consumes 300mA which is the same as the output current. This is a standard technique that is employed to approximate the current drawn from the converter especially for higher efficiencies. We could have utilized this approach, but now we know how to solve for the max input current for any converter. | Using Digikey PCB Trace Width Calculator . | The maximum input current is 0.3A and we are designing for a 1 oz copper thickness . | . | A required trace width of 0.148mm (5.83mils) is obtained | . ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-required-input-current-and-pcb-trace-thickness-for-switching-converters",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-required-input-current-and-pcb-trace-thickness-for-switching-converters"
  },"64": {
    "doc": "Buck Converter",
    "title": "Buck Converter",
    "content": " ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html"
  },"65": {
    "doc": "DC Current Sensing",
    "title": "DC Current Sensing Hardware",
    "content": ". The current at the input of the power inverter is measured using a Hall-effect current sensor which leverages its electromagnetic properties to perform an isolated, low resistive measurement. After passing through the series connected sensor, it is then delivered to the supply rails of the H-bridge where it continues standard PWM inversion operation. Figure X. DC Current Sensing Block Diagram . ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#dc-current-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#dc-current-sensing-hardware"
  },"66": {
    "doc": "DC Current Sensing",
    "title": "Hall-Effect Theory",
    "content": "To understand Hall-effect current sensors, it is useful to have an understanding of the two fundamental laws of electromagnetism: . | Lorentz Force Law | Ampere‚Äôs Law | . Instead of merely defining the laws, this section examines how they manifest themselves in the operation of the device. Consider a conductive element where a current flows. The yellow balls represent electrons that are evenly distributed when flowing through a conductor. The current flow is denoted as ‚ÄúI‚Äù. Ampere‚Äôs law gives rise to a magnetic field generated around the conductor in accordance with the right-hand rule and it is proportional to the current that is flowing. Additionally, if an external magnetic field is applied near the conductor (strongest when perpendicular due to Lorentz force), the electrons will be deflected and accumulate in one area leaving the opposite side with a net positive charge. The charge separation between both ends can be measured ‚Äî known as the hall-voltage. Figure X. (a) Uniform Electron Distribution in a Current-Carrying Conductor (b) Electron Accumulation Due to Lorentz Force Under a Magnetic Field . ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#hall-effect-theory",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#hall-effect-theory"
  },"67": {
    "doc": "DC Current Sensing",
    "title": "TMCS1108 Current Sensor",
    "content": "In this design, the Hall-effect current sensor of choice is the TMCS1108. It internally measures the hall-voltage and amplifies it to produce an analog voltage output which is proportional to the sensed current. This analog voltage can be calculated using the TMCS1108 datasheet provided equation in page 12: . \\[V_{OUT} = S \\times I_{IN} + V_{OUT,0A}\\] where: . | $V_{OUT}$ is the analog output voltage. | S is the ideal sensitivity of the device. | $I_{IN}$ is the isolated input current. | $V_{OUT,0A}$ is the zero current output voltage for the device variant. | . As this design employs the TMCS1108A4BQDR device variant, this features a sensitivity of 400mV/A. This describes the relation between the output analog voltage and current input where the output changes 400mV for every 1A of detected current. Higher sensitivities are generally favorable, as they result in a greater voltage response per unit of current. The non-zero current output is due to the device bidirectionality of the sensor, where the output is centered at mid-supply as noted in page 3 of the TMCS1108 datasheet. \\[V_{OUT,0A} = 0.5 √ó V_{S}\\] where: . | $V_{OUT,0A}$ is the zero current output voltage for the device variant. | $V_{S}$ is the supply voltage to the chip. | . Since the chip is powered by a 5V supply, at no current input, the output analog voltage resides at 2.5V. For positive current, the output voltage increases above 2.5V and conversely for negative current, the output decreases below 2.5V. The analog output voltage is then measured by the analog pin of our ATMEGA328P, where it is converted to a digital value between the range of 0-1023. After the MCU has an understanding of what the voltage signal is in the digital domain, the current for the DC input is computed using a restructured form of the previous equation. \\[I_{IN} = \\frac{V_{OUT} - V_{OUT,0A}}{S}\\] This conversion ultimately produces an accurate current reading based on the previously discussed hall-effect phenomenon and fulfills the goal of measuring the DC input current of the Atinverter V2 device. ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#tmcs1108-current-sensor",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#tmcs1108-current-sensor"
  },"68": {
    "doc": "DC Current Sensing",
    "title": "DC Current Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html"
  },"69": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing Library Feature",
    "content": ". ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#dc-vi-sensing-library-feature",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#dc-vi-sensing-library-feature"
  },"70": {
    "doc": "DC V/I Sensing",
    "title": "üìã Overview",
    "content": "The DC Voltage and Current Sensing feature provides an interface for monitoring the input voltage and current of the PWM inverter. It utilizes the onboard ADC pins of the ATMEGA328P, along with TMCS1108A4BQDR Hall-effect current sensor. Voltage is measured through a resistive voltage divider, while current is measured using the analog output of the current sensor. These signals can be obtained through methods which use raw readouts of the ADC or for improved accuracy, through a running average sampling method. ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-overview",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-overview"
  },"71": {
    "doc": "DC V/I Sensing",
    "title": "üìå Pin Assignments",
    "content": ". Table X. ATMEGA328P Pin Configuration for DC Sensing . | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | DC Voltage Sensing | V_DC_PIN | A0 | INPUT | . | DC Current Sensing | I_DC_PIN | A1 | INPUT | . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-pin-assignments"
  },"72": {
    "doc": "DC V/I Sensing",
    "title": "üìÇ Header File Definitions",
    "content": "Implementation in Atinverter.h: . // TMCS1108 Current Sensor Parameters #define SENSOR_GAIN_MV_PER_A 400.0f #define MV_TO_V 1000.0f #define VOUT_0A 2.5f // ADC Parameters #define VREF 5.0f #define ADC_ATMEGA328P_MAX_VALUE 1023.0f // Moving Average Samples #define MA_SAMPLES 10 // DC Voltage and Current Pin Definitions static const int V_DC_PIN = A0; static const int I_DC_PIN = A1; // DC Voltage Sensing Resistor Values static const unsigned long Rvs1 = 120000; static const unsigned int Rsv2 = 9900; // Parameters for Vdc Moving Average static const int Vdc_num_readings = MA_SAMPLES; float Vdc_readings[MA_SAMPLES]; int Vdc_read_index = 0; float Vdc_total = 0; // Parameters for Idc Moving Average static const int Idc_num_readings = MA_SAMPLES; float Idc_readings[MA_SAMPLES]; int Idc_read_index = 0; float Idc_total = 0; // Method Declarations float getVdc(); float getIdc(); float getAvgDC(bool isVdc, float signalValue); . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-header-file-definitions",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-header-file-definitions"
  },"73": {
    "doc": "DC V/I Sensing",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-method-descriptions"
  },"74": {
    "doc": "DC V/I Sensing",
    "title": "getVdc()",
    "content": "Purpose: Senses and returns the input DC voltage. Pseudocode: . | Read raw ADC value from ATMEGA328P analog pin connected to sensing voltage | Translate the digital ADC reading into its analog voltage equivalent . | \\[Sensed\\ Voltage = \\left( \\frac{Reference\\ Voltage \\times ADC\\ Reading}{2^{(ADC\\ Bits)} - 1} \\right)\\] | . | Convert the sensed voltage to the DC input voltage using rearranged voltage divider . | \\[Input\\ DC\\ Voltage = Sensed\\ Voltage \\times \\frac{(Top\\ Resistor + Bottom\\ Resistor)}{Top\\ Resistor}\\] | . | Return the calculated DC input voltage | . Implementation in Atinverter.cpp: . float Atinverter::getVdc() { int digital_val = analogRead(V_DC_PIN); float Vdc_sense = (VREF * digital_val) / (ADC_ATMEGA328P_MAX_VALUE); float Vdc = Vdc_sense * (Rvs1 + Rsv2) / Rsv2; return Vdc; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getvdc",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getvdc"
  },"75": {
    "doc": "DC V/I Sensing",
    "title": "getIdc()",
    "content": "Purpose: Senses and returns the input DC current. Pseudocode: . | Read raw ADC value from ATMEGA328P analog pin connected to TMCS1108 analog output | Translate the digital ADC reading into its analog voltage equivalent . | \\[Output\\ Voltage = \\left( \\frac{Reference\\ Voltage \\times ADC\\ Reading}{2^{(ADC\\ Bits)} - 1} \\right)\\] | . | Compute the input current using the transfer function from the TMCS1108 datasheet (equation 1 on page 12) . | \\[Input\\ DC\\ Current = \\left( \\frac{Output\\ Voltage - Zero\\ Current\\ Output\\ Voltage}{Sensitivity} \\right)\\] | . | Return the calculated DC input current | . Implementation in Atinverter.cpp: . float Atinverter::getIdc() { int digital_val = analogRead(I_DC_PIN); float Vout = (VREF * digital_val) / (ADC_ATMEGA328P_MAX_VALUE); float Idc = (Vout - VOUT_0A) / SENSOR_GAIN_MV_PER_A * MV_TO_V; return Idc; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getidc",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getidc"
  },"76": {
    "doc": "DC V/I Sensing",
    "title": "getAvgDC(bool isVdc, float signalValue)",
    "content": "Purpose: Computes and returns the moving average for the input DC voltage or current based on a pre-defined sample count. Pseudocode: . | Decide which sampling array will be utilized based on user input | Store the most recent value received in the buffer | Add the readings to the running total | Increment the sampling array index | Check if read index is above the buffer size . | If yes, reset buffer index | If no, continue | . | Compute the average signal using total over the number of readings | Substract the oldest reading to prepare for new readng | Return the averaged signal | . Implementation in Atinverter.cpp: . float Atinverter::getAvgDC(bool isVdc, float signalValue) { const int num_readings = isVdc ? Vdc_num_readings : Idc_num_readings; float* readings = isVdc ? Vdc_readings : Idc_readings; int&amp; read_index = isVdc ? Vdc_read_index : Idc_read_index; float&amp; total = isVdc ? Vdc_total : Idc_total; readings[read_index] = signalValue; total += readings[read_index]; read_index++; if (read_index &gt;= num_readings){ read_index = 0; } float avg_signal = total / num_readings; total -= readings[read_index]; return avg_signal; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getavgdcbool-isvdc-float-signalvalue",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getavgdcbool-isvdc-float-signalvalue"
  },"77": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing",
    "content": ". ",
    "url": "/software/library/features/dc_vi_sensing_feature.html",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html"
  },"78": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing Program Modules",
    "content": ". Purpose: These two standalone programs (Vdc_Sensing.ino and Idc_Sensing.ino) showcase how to use the Atinverter library‚Äôs DC sensing features to monitor the input DC voltage and current of the PWM inverter. Both modules verify hardware connections, retrieve both raw and averaged sensor values, and employ the Timer 2 based delaying feature. ",
    "url": "/software/modules/dc_vi_sensing_module.html#dc-vi-sensing-program-modules",
    
    "relUrl": "/software/modules/dc_vi_sensing_module.html#dc-vi-sensing-program-modules"
  },"79": {
    "doc": "DC V/I Sensing",
    "title": "Vdc_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance | Initialize the serial monitor for displaying DC voltage readings | Begin PWM operation at a specified frequency of 50Hz or 60Hz | Initialize Timer 2 for time-based delay functionality | Read the raw input DC voltage | Print raw input DC voltage to the serial monitor | Pass the most recent reading to the getAvgDC method to calculate the running average | Print averaged input DC voltage to the serial monitor | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Input DC Voltage Sensing.\")); atinverter.startPWM(60); atinverter.initTimer2Delay(); } void loop() { float raw_Vdc = atinverter.getVdc(); Serial.print(F(\"Raw Vdc : \")); Serial.print(raw_Vdc); Serial.println(F(\"V\")); float avg_Vdc = atinverter.getAvgDC(true, raw_Vdc); Serial.print(F(\"Avg Vdc : \")); Serial.print(avg_Vdc); Serial.println(F(\"V\")); Serial.println(); atinverter.delay2(500); } . ",
    "url": "/software/modules/dc_vi_sensing_module.html#vdc_sensingino",
    
    "relUrl": "/software/modules/dc_vi_sensing_module.html#vdc_sensingino"
  },"80": {
    "doc": "DC V/I Sensing",
    "title": "Idc_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance set to 50Hz or 60Hz mode | Initialize the serial monitor for displaying DC current readings | Begin PWM operation at a specified frequency of 50Hz or 60Hz | Initialize Timer 2 for time-based delay functionality | Read the raw input DC current | Print raw input DC current to the serial monitor | Pass the most recent reading to the getAvgDC method to calculate the running average | Print averaged input DC current to the serial monitor | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Input DC Current Sensing.\")); atinverter.startPWM(60); atinverter.initTimer2Delay(); } void loop() { float raw_Idc = atinverter.getIdc(); Serial.print(F(\"Raw Idc : \")); Serial.print(raw_Idc); Serial.println(F(\"A\")); float avg_Idc = atinverter.getAvgDC(false, raw_Idc); Serial.print(F(\"Avg Idc : \")); Serial.print(avg_Idc); Serial.println(F(\"A\")); Serial.println(); atinverter.delay2(500); } . ",
    "url": "/software/modules/dc_vi_sensing_module.html#idc_sensingino",
    
    "relUrl": "/software/modules/dc_vi_sensing_module.html#idc_sensingino"
  },"81": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing",
    "content": " ",
    "url": "/software/modules/dc_vi_sensing_module.html",
    
    "relUrl": "/software/modules/dc_vi_sensing_module.html"
  },"82": {
    "doc": "DC Voltage Sensing",
    "title": "DC Voltage Sensing Hardware",
    "content": ". Voltage sensing of the DC input ($V_{DC}$) is achieved through a simple resistive divider. The resistive divider is made up of a limiting current resistor ($R_{limit}$) paired with a sensing resistor ($R_{sense}$). The voltage across the sensing resistance is measured by an ATMEGA328P analog pin which senses a voltage in the range of 0-5V ($V_{sense}$). It should be noted that the ATMEGA328P I/O pins cannot exceed 5V, as doing so may result in permanent damage to the MCU. Figure X. DC Voltage Sensing Circuit . Resistors values are chosen based on this condition as well as drawing an insignificant amount of power from the DC input, since the current in this path is to be delivered primarily to the output load. The resistor values of $R_{limit} = 120k\\Omega$ and $R_{sense} = 10k\\Omega$ were chosen based on the standard voltage divider equation: . \\[V_{sense} = V_{DC} \\times \\left( \\frac{R_{sense}}{R_{sense}\\times R_{limit}} \\right)\\] Given that the nominal DC input range is 12V to 48V, this translates to a sensed voltage as low as 0.92V and a high as 3.69V. It is evident that the full scale range of the analog pin is not used (0-5V), but this is intentional to account for potential overvoltage driving at the DC pin. Nonetheless, the 10 bit analog to digital converter (ADC) of the ATMEGA328P works as necessary in detecting the DC voltage based on the design parameters selected. ",
    "url": "/hardware/atinverter_v2/dc_volt_sensing_hw.html#dc-voltage-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/dc_volt_sensing_hw.html#dc-voltage-sensing-hardware"
  },"83": {
    "doc": "DC Voltage Sensing",
    "title": "DC Voltage Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/dc_volt_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/dc_volt_sensing_hw.html"
  },"84": {
    "doc": "Experimentation",
    "title": "Experimentation",
    "content": ". The experimentation is predicated on the sequential testing of the fully populated Atinverter V2 PCB as well as its integration with various software modules to evaluate and diagnose system-level functionality. Standard PCB assembly practices were observed throughout the process, including component orientation checks, solder joint inspections, thorough visual examination, and continuity testing. To successfully validate the operation of the Atinverter V2 device, verification of the following core subsystems is required: . | 5V Buck and 12V Boost Power Supplies | ATMEGA328P Bootloaded Status | PWM Inversion | DC Voltage and Current Sensing | AC Voltage and Current Sensing | . In the next few sections, each subsystem is reported on their verification status, both from a hardware and software functionality standpoint. ",
    "url": "/hardware/atinverter_v2/experimentation.html#experimentation",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#experimentation"
  },"85": {
    "doc": "Experimentation",
    "title": "Workbenches",
    "content": "To facilitate thorough testing of the various subsystems, two reliable workbenches were utilized. The primary workbench served as the main station for general testing activities, while the secondary workbench was dedicated specifically to validating the DC and AC current sensing functionality of the Atinverter V2 board. Figure X. Main Workbench . The DC input is powered by a Rigol DP832, using one or two of the channels depending on the voltage needed. When voltages requirements are above 30V, channels 1 and 2 are configured in series to deliver up to a 48V. The DM3058E digital multimeter is used to precisely measure the value of both the DC input voltage and the load resistance. The Keysight DSOX1204G oscilloscope captures key waveforms of the Atinverter V2 board including the power supply levels and the power inverter signals from the input to output. The host PC operates as the software hub, as this is where the user selects and uploads the firmware to the Atinverter V2 board via the FTDI to USB cable. Figure X. Workbench for Verifying DC and AC Current Sensing . The second workbench builds upon the main setup and is optimized for testing the DC and AC current sensing functionality. It consists of the previously mentioned instruments, but with the addition of a current probe and current probe amplifier (Tektronix AM503). The current probe operates on the principle of magnetic induction, where it senses the current flowing through the conductor that clamps around the wire carrying the load current. To ensure accurate scaling of the current signal, the oscilloscope is set to a fixed vertical scale value 10mV/div and the amplifier gain is adjusted accordingly based on the expected current magnitude. A high power resistive load box is connected to the output of the Atinverter V2 to set a known load condition for the DC and AC current tests. In the following sections, a series of captures and data are displayed to report on the Atinverter V2 device behavior. ",
    "url": "/hardware/atinverter_v2/experimentation.html#workbenches",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#workbenches"
  },"86": {
    "doc": "Experimentation",
    "title": "5V Buck and 12V Boost Power Supplies",
    "content": "A functioning board depends fundamentally on its power supplies. Before evaluating the rest of the hardware and software systems, the onboard power sources were inspected to verify appropriate voltage levels. Figure X. R-78HE5.0-0.3 5V Buck Output . Figure X. TLV61046ADBVR 12V Boost Output . Figure X. TLV61046ADBVR 12V Boost Output Ripple . | Power supplies are functional, marginal deviations from the expected value. | 12V Boost converter peak-to-peak ripple is significantly larger than the simulated value (72.88 mV as per the Boost Converter section), but not an issue since the output is still within the power supply conditions of the IR2302 (5V-20V). | . ",
    "url": "/hardware/atinverter_v2/experimentation.html#5v-buck-and-12v-boost-power-supplies",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#5v-buck-and-12v-boost-power-supplies"
  },"87": {
    "doc": "Experimentation",
    "title": "ATMEGA328P Bootloaded Status",
    "content": "To confirm successful bootloading and basic functionality of the ATMEGA328P microcontroller, the Blink.ino was executed. Figure X. Atinverter V2 Visual LED Blinking . | ATMEGA328P is operational and performs LED blinking in accordance with the program routine. | . ",
    "url": "/hardware/atinverter_v2/experimentation.html#atmega328p-bootloaded-status",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#atmega328p-bootloaded-status"
  },"88": {
    "doc": "Experimentation",
    "title": "PWM Inversion",
    "content": "This section verifies 50Hz and 60Hz PWM inversion employing the 50Hz_PWM_Inverter.ino and 60Hz_PWM_Inverter.ino software. Given the sequential waveform behavior across different stages of the power inverter, the section is organized into subsections to highlight waveforms specific to each stage. PWM Generation . Figure X. PWMA (yellow) and PWMB (green) Waveforms with $f_{sw} = 31,372kHz, f_{ac} = 50Hz$ . Figure X. PWMA (yellow) and PWMB (green) Waveforms with $f_{sw} = 31,372kHz, f_{ac} = 60Hz$ . Figure X. PWMA (yellow) Switching Frequency Verification . Figure X. PWMB (green) Switching Frequency Verification . | The PWM generation by the ATMEGA328P‚Äôs digital pins is functioning as intended. The PWM outputs exhibit a 180¬∞ phase offset as they are complementary and align with the expected fundamental and switching frequencies of 50Hz or 60Hz and 31.372kHz respectively. | . Gate Driver . Figure X. High- and Low-side Switch Gate Driver Waveforms of $f_{ac} = 50Hz$, Respectively: PWMA_HO (yellow), PWMB_HO (green), PWMA_LO (blue), and PWMB_LO (red) . Figure X. High- and Low-side Switch Gate Driver Waveforms of $f_{ac} = 60Hz$, Respectively: PWMA_HO (yellow), PWMB_HO (green), PWMA_LO (blue), and PWMB_LO (red) . | The software generated PWM waveforms provided to the input of the gate drivers are properly level-shifted for both the high-side gate drive output (HO) and low-side gate drive output (LO). The LO output is level-shifted from the 5V logic input to 12V due to the internal CMOS structure of the IR2302, which toggles the output between ground and the 12V gate driver supply. The HO, is level-shifted from the 5V logic input to approximately 24V. This level shift is a result of the 12V gate driver supply connected to the $V_{B}$ node through a diode and the bootstrap capacitor voltage which adds another 12V when fully charged. This bootstrap capacitor is charged when the low-side switch is active while the high-side switch is on and vice versa when the high-side switch is active and the low-side switch is off, the bootstrap capacitor discharges to the HO node. | . H-Bridge and LC Filter . Figure X. 50Hz Output Waveform at Load+ (yellow) and Load‚àí (green) with $V_{DC_{in}} = 12V$ . Figure X. 50Hz Differential AC Output Waveform (pink) with $V_{DC_{in}} = 12V$ . Figure X. 50Hz Output Waveform at Load+ (yellow) and Load‚àí (green) with $V_{DC_{in}} = 48V$ . Figure X. 50Hz Differential AC Output Waveform (pink) with $V_{DC_{in}} = 48V$ . Figure X. 60Hz Output Waveform at Load+ (yellow) and Load‚àí (green) with $V_{DC_{in}} = 12V$ . Figure X. 60Hz Differential AC Output Waveform (pink) with $V_{DC_{in}} = 12V$ . Figure X. 60Hz Output Waveform at Load+ (yellow) and Load‚àí (green) with $V_{DC_{in}} = 48V$ . Figure X. 60Hz Differential AC Output Waveform (pink) with $V_{DC_{in}} = 48V$ . | The PWM inverter was subjected to testing between the predefined range of 24V - $96V_{pkpk}$ using a 12V - 48V DC input. Oscilloscope captures were obtained at both fundamental frequencies of 50Hz and 60Hz, measuring across the load terminals to illustrate how the differential AC waveform is synthesized from the positive and negative half-cycles. Overall, the output waveform behavior is consistent with theoretical expectations. | . ",
    "url": "/hardware/atinverter_v2/experimentation.html#pwm-inversion",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#pwm-inversion"
  },"89": {
    "doc": "Experimentation",
    "title": "Sensing Networks",
    "content": "This portion of the report addresses and experiments with the four sensing operations for the power inverter using the software modules Vdc_Sensing.ino, Idc_Sensing.ino, Vac_Sensing.ino, and Iac_Sensing.ino. Although this section does not make the distinction between the 50Hz or 60Hz fundamental frequency testing, this is intentional as the sensed values are not expected to vary significantly with frequency. Testing was performed for the DC input voltage of 12V - 48V with representative results for both 12V and 48V documented in this section. Figure X. 12V DC Input Multimeter Measurement . Figure X. 48V DC Input Multimeter Measurement . DC Voltage Sensing . Figure X. Start-Up DC Voltage Readings from the Arduino IDE Serial Monitor at $V_{DC_{in}} = 12V$ . Figure X. Steady-State DC Voltage Readings from the Arduino IDE Serial Monitor at $V_{DC_{in}} = 12V$ . Figure X. Start-Up DC Voltage Readings from the Arduino IDE Serial Monitor at $V_{DC_{in}} = 48V$ . Figure X. Steady-State DC voltage readings from the Arduino IDE Serial Monitor at $V_{DC_{in}} = 48V$ . | Execution of the Vdc_Sensing.ino program at both 12V and 48V DC levels produces results that are quite favorable. Start up conditions were in accordance with expected operation as the running average logic tells us that the DC voltage value improves in accuracy once it completely fills its buffer. Additionally, under steady-state conditions the sensed voltage closely matched the measured value, with deviations limited to a few tens of millivolts‚Äîwell within the acceptable range for this design. | . DC Current Sensing . Figure X. Arduino IDE Serial Monitor DC Current Readouts for $24.5\\Omega$ Load . Figure X. Arduino IDE Serial Monitor DC Current Readouts for $24.5\\Omega$ Load . Figure X. Arduino IDE Serial Monitor DC Current Readouts for $18\\Omega$ Load . Table X. DC Current Sensing Load Tests at 12V DC Input . | Nominal Load Resistance | Nominal Load Current | Measured Load Resistance | Calculated Load Current | Sensed Load Current | . | 69.6Œ© | 0.172A | 71.422Œ© | 0.168A | ¬† | . | 34.8Œ© | 0.333A | 36.003Œ© | 0.333A | ¬† | . | 23.2Œ© | 0.517A | 24.278Œ© | 0.494A | ¬† | . | 17.4Œ© | 0.689A | 18.087Œ© | 0.663A | ¬† | . Table X. DC Current Sensing Load Tests at 48V DC Input . | Nominal Load Resistance | Nominal Load Current | Measured Load Resistance | Calculated Load Current | Sensed Load Current | . | 69.6Œ© | 0.689A | 71.422Œ© | 0.689A | ¬† | . | 34.8Œ© | 1.378A | 36.003Œ© | 1.333A | ¬† | . | 23.2Œ© | 2.068A | 24.278Œ© | 1.977A | ¬† | . | 17.4Œ© | 2.758A | 18.087Œ© | 2.653A | ¬† | . | A series of four load tests were conducted to validate the performance of the DC current sensing program. The selected load resistances span a range that covers the full output current capability of the Atinverter V2 (rated up to 2.8A), including operation at the highest DC input level of 48V. | . AC Voltage Sensing . Figure X. Arduino IDE Serial Monitor AC Voltage Sensing with $V_{DC_{in}} = 12V$ . Figure X. Arduino IDE Serial Monitor AC Voltage Sensing with $V_{DC_{in}} = 48V$ . | The Vac_Sensing.ino program was evaluated at both 12V and 48V DC input levels which correspond to expected RMS output voltages of $\\frac{12V}{\\sqrt{2}} \\approx 8.49V$ and $\\frac{48V}{\\sqrt{2}} \\approx 33.94V$. Unlike the DC sensing routine, the AC voltage sensing program does not differentiate between startup and steady-state conditions, as it employs a fixed time-based sampling window instead of a running average. | The AC voltage RMS sensing was found to be fairly accurate for 12V DC input level, with only millivolt deviations. However, for 48V DC input, data readouts were quite erroneous, with a discrepancy of about 8V. It turns out that the sampling resistor, $R_{samp}$, was selected at a value of $100\\Omega$ prior to the simulated value of $6.8\\Omega$, which produces a larger sampling voltage. Due to the excessive initial magnitude, the op-amp output saturated, leading to inaccurate RMS measurements. | . AC Current Sensing . Table X. AC Current Sensing Load Tests at 12V DC Input . | Nominal Load Resistance | Nominal Load Current | Measured Load Resistance | Calculated Load Current | Sensed Load Current | . | 69.6Œ© | 0.172A | 71.422Œ© | 0.168A | ¬† | . | 34.8Œ© | 0.333A | 36.003Œ© | 0.333A | ¬† | . | 23.2Œ© | 0.517A | 24.278Œ© | 0.494A | ¬† | . | 17.4Œ© | 0.689A | 18.087Œ© | 0.663A | ¬† | . Table X. AC Current Sensing Load Tests at 48V DC Input . | Nominal Load Resistance | Nominal Load Current | Measured Load Resistance | Calculated Load Current | Sensed Load Current | . | 69.6Œ© | 0.689A | 71.422Œ© | 0.689A | ¬† | . | 34.8Œ© | 1.378A | 36.003Œ© | 1.333A | ¬† | . | 23.2Œ© | 2.068A | 24.278Œ© | 1.977A | ¬† | . | 17.4Œ© | 2.758A | 18.087Œ© | 2.653A | ¬† | . The AC load current sensing ca . ",
    "url": "/hardware/atinverter_v2/experimentation.html#sensing-networks",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html#sensing-networks"
  },"90": {
    "doc": "Experimentation",
    "title": "Experimentation",
    "content": ". ",
    "url": "/hardware/atinverter_v2/experimentation.html",
    
    "relUrl": "/hardware/atinverter_v2/experimentation.html"
  },"91": {
    "doc": "Hardware",
    "title": "Hardware",
    "content": ". Atinverter V1 Atinverter V2 . ",
    "url": "/hardware/hardware.html",
    
    "relUrl": "/hardware/hardware.html"
  },"92": {
    "doc": "Home",
    "title": "Atinverter Documentation",
    "content": "Explore the documentation to learn more about this open source power inverter! . Vision Hardware Software . ",
    "url": "/#atinverter-documentation",
    
    "relUrl": "/#atinverter-documentation"
  },"93": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"94": {
    "doc": "Inter-Board Communication",
    "title": "I2C Inter-Board Communication Hardware",
    "content": ". | Will be documented once I2C bus is verified | . ",
    "url": "/hardware/atinverter_v2/inter_board_comms.html#i2c-inter-board-communication-hardware",
    
    "relUrl": "/hardware/atinverter_v2/inter_board_comms.html#i2c-inter-board-communication-hardware"
  },"95": {
    "doc": "Inter-Board Communication",
    "title": "Inter-Board Communication",
    "content": " ",
    "url": "/hardware/atinverter_v2/inter_board_comms.html",
    
    "relUrl": "/hardware/atinverter_v2/inter_board_comms.html"
  },"96": {
    "doc": "Library",
    "title": "Atinverter V2 Library",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 library! . ",
    "url": "/software/library/library.html#atinverter-v2-library",
    
    "relUrl": "/software/library/library.html#atinverter-v2-library"
  },"97": {
    "doc": "Library",
    "title": "Library",
    "content": " ",
    "url": "/software/library/library.html",
    
    "relUrl": "/software/library/library.html"
  },"98": {
    "doc": "Features",
    "title": "Atinverter V2 Library Features",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 library features! . ",
    "url": "/software/library/features/library_features.html#atinverter-v2-library-features",
    
    "relUrl": "/software/library/features/library_features.html#atinverter-v2-library-features"
  },"99": {
    "doc": "Features",
    "title": "Features",
    "content": " ",
    "url": "/software/library/features/library_features.html",
    
    "relUrl": "/software/library/features/library_features.html"
  },"100": {
    "doc": "Reference",
    "title": "Atinverter V2 Library Reference",
    "content": ". The Atinverter V2 library is comprised of two files: Atinverter.h and Atinverter.cpp. The header file serves as the blueprint containing the Atinverter class definition, along with its method declarations and member variables. The implementation for the Atinverter class and initilization of member variables are defined in Atinverter.cpp. At a high level, the Atinverter is essentially just two files as illustrated below: . Figure X. Atinverter Library High Level . Upon further inspection of the Atinverter Library, we can observe that it is organized into five main sections based on functionality. The nodes for the five features of the library are interactive‚Äîclick to explore specific software functionality and learn more about its design. Additionally, the code is thoroughly documented within the program files, so these sections will focus primarily on providing an overview of the design and any algorithms that were implemented. Figure X. Atinverter Library Features . ",
    "url": "/software/library/library_reference.html#atinverter-v2-library-reference",
    
    "relUrl": "/software/library/library_reference.html#atinverter-v2-library-reference"
  },"101": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/software/library/library_reference.html",
    
    "relUrl": "/software/library/library_reference.html"
  },"102": {
    "doc": "Set Up",
    "title": "Atinverter Library Set Up",
    "content": "A guide to help your Arduino IDE recognize and use the Atinverter user-defined library . You might be thinking: . üí≠ ‚ÄúOkay, I downloaded the software files from the GitHub repository ‚Äî now what? Can I just open some random file like blink.ino and run the code?‚Äù . You‚Äôre almost there! There is just one important step that needs to happen first; We need ensure that the Arduino IDE knows where to find the Atinverter library files (Atinverter.cpp, Atinverter.h), or else you‚Äôll run into the notorious: . fatal error: Atinverter.h: No such file or directory . ",
    "url": "/software/library/library_setup.html#atinverter-library-set-up",
    
    "relUrl": "/software/library/library_setup.html#atinverter-library-set-up"
  },"103": {
    "doc": "Set Up",
    "title": "üìÅ How Arduino Handles Libraries",
    "content": "The Arduino IDE looks for user-defined libraries in a specific directory on your computer. Simply placing .cpp or .h files in the same directory as the .ino files you wish to run isn‚Äôt enough. Here‚Äôs where those locations are: . üîç If you‚Äôre on Windows, it‚Äôll be in: . C:\\Users&lt;YourUsername&gt;\\Documents\\Arduino\\libraries\\ . üîç If you‚Äôre on macOS or Linux, it‚Äôll be in: . ~/Documents/Arduino/libraries/ . ",
    "url": "/software/library/library_setup.html#-how-arduino-handles-libraries",
    
    "relUrl": "/software/library/library_setup.html#-how-arduino-handles-libraries"
  },"104": {
    "doc": "Set Up",
    "title": "‚úÖ What To Do",
    "content": ". | Navigate to the Atinverter library folder in the repository. It contains the source files Atinverter.cpp, Atinverter.h, and the metadata file library.properties. It is located in: . \\AtInverter\\software\\Library . | Copy the Atinverter folder to your Arduino libraries folder as described in How Arduino Handles Libraries . | . üì∏ You should expect to see something like this in your Arduino libraries folder: . ",
    "url": "/software/library/library_setup.html#-what-to-do",
    
    "relUrl": "/software/library/library_setup.html#-what-to-do"
  },"105": {
    "doc": "Set Up",
    "title": "üöÄ You‚Äôre Good to Go",
    "content": "Once the Atinverter library is in the right place, you can use it any sketch with: . #include \"Atinverter.h\" . ",
    "url": "/software/library/library_setup.html#-youre-good-to-go",
    
    "relUrl": "/software/library/library_setup.html#-youre-good-to-go"
  },"106": {
    "doc": "Set Up",
    "title": "Set Up",
    "content": " ",
    "url": "/software/library/library_setup.html",
    
    "relUrl": "/software/library/library_setup.html"
  },"107": {
    "doc": "UML Diagram",
    "title": "Atinverter UML Diagram",
    "content": ". Needs to be updated to reflect new changes!! . classDiagram class Atinverter { + LED1R_PIN : int + LED1G_PIN : int + LED2R_PIN : int + LED2G_PIN : int - VI_AC_CS_PIN : int - VI_AC_MOSI_PIN : int - VI_AC_MISO_PIN : int - VI_AC_SCLK_PIN : int - V_DC_PIN : int - I_DC_PIN : int - PWM_A_PIN : int - PWM_B_PIN : int - I2C_SDA_PIN : int - I2C_SCL_PIN : int - PRORESET_PIN : int - GATESD_PIN : int - Rvs1 : unsigned long - Rsv2 : unsigned int - num_readings : int - readings : float[num_readings] - read_index : int - total : float - is50Hz : bool - sin_i : int - pwm_i : int - OK : int - sin50HzPWM : int[312] - sin60HzPWM : int[261] + Atinverter() + setUpPinMode() : void + readVdc() : float + readAvgVdc(Vdc : float) : float + readIdc() : float + readAvgIdc(Idc : float) : float + setUpSPI() : void + readADC() : int + set1LED(led : int, state : int) : void + set2LED(t_delay : int) : void + enablePWM() : void + disablePWM() : void + startPWM(is50HzMode : bool) : void + pwmISR() : void } . ",
    "url": "/software/library/library_uml.html#atinverter-uml-diagram",
    
    "relUrl": "/software/library/library_uml.html#atinverter-uml-diagram"
  },"108": {
    "doc": "UML Diagram",
    "title": "UML Diagram",
    "content": " ",
    "url": "/software/library/library_uml.html",
    
    "relUrl": "/software/library/library_uml.html"
  },"109": {
    "doc": "Main",
    "title": "Main Program Module",
    "content": ". | To be documented in the future | . ",
    "url": "/software/modules/main_module.html#main-program-module",
    
    "relUrl": "/software/modules/main_module.html#main-program-module"
  },"110": {
    "doc": "Main",
    "title": "Main",
    "content": " ",
    "url": "/software/modules/main_module.html",
    
    "relUrl": "/software/modules/main_module.html"
  },"111": {
    "doc": "Modules",
    "title": "Atinverter V2 Library",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 program modules! . ",
    "url": "/software/modules/modules.html#atinverter-v2-library",
    
    "relUrl": "/software/modules/modules.html#atinverter-v2-library"
  },"112": {
    "doc": "Modules",
    "title": "Modules",
    "content": " ",
    "url": "/software/modules/modules.html",
    
    "relUrl": "/software/modules/modules.html"
  },"113": {
    "doc": "OV and Reset Protection",
    "title": "Overvoltage and Reset Protection Hardware",
    "content": ". The goal is to implement a mechanism such that the output of the power inverter is disabled when the H-bridge DC input supply exceeds a safe operating voltage or when the system is manually reset via a user command. This forms the basis of the Overvoltage and Reset Protection feature (OVRP). Without these two components of protection hardware in place, the output could remain active at unsafe voltages and the user would not be able to able to have real-time control of the inverter‚Äôs operational state. To implement this functionality, the following circuit was designed: . Figure X. Overvoltage and Reset Protection Circuitry . It consists of a comparator op-amp, a NOR logic gate, and a few resistors for pull up/down and voltage division functionality. Although not explicitly displayed on the diagram, it is useful to know that the nets !GateSD and ProReset are connected to pull down resistors and CompOut is connected to a pull up resistor. ",
    "url": "/hardware/atinverter_v2/ov_reset_prot_hw.html#overvoltage-and-reset-protection-hardware",
    
    "relUrl": "/hardware/atinverter_v2/ov_reset_prot_hw.html#overvoltage-and-reset-protection-hardware"
  },"114": {
    "doc": "OV and Reset Protection",
    "title": "Functionality Breakdown",
    "content": "Overvoltage Detection . The overvoltage detection is handled by the op amp comparator. It monitors a scaled voltage of H-bridge DC supply at the positive input (CompP) and compares it to a fixed 2.5V reference at the negative input (CompN). The scaled DC supply voltage at CompP is produced using a voltage divider consisting of $R_{compP}$ and $R_{proPD1}$: . \\[V_{CompP} = V_{DC} \\times \\frac{R_{proPD1}}{R_{compP} + R_{proPD1}}\\] The shutdown threshold to set to 52.5V (2.5V scaled voltage), which includes a 4.5‚ÄØV margin above the inverter‚Äôs max design input of 48‚ÄØVpk, to accommodate transient spikes and power supply variation. \\[V_{CompP} = 52.5V \\times \\frac{5k\\Omega}{100k\\Omega + 5k\\Omega} = 2.5V\\] The 2.5V reference voltage at CompN is generated from the logic supply voltage using a symmetric voltage divider formed by $R_{proPU1}$ and $R_{proPU2}$: . \\[V_{CompN} = V_{cc} \\times \\frac{R_{proPU2}}{R_{proPU2} + R_{proP12}}\\] \\[V_{CompN} = 5V \\times \\frac{10k\\Omega}{10k\\Omega + 10k\\Omega} = 2.5V\\] When the scaled inverter supply at CompP exceeds the reference voltage at CompN: . \\[V_{CompP} &gt; V_{CompN}\\] the comparator output (CompOut) goes high, triggering a shutdown condition. Manual Reset Control . A shutdown can also be triggered using the ProReset line, which is driven by an ATMEGA328P GPIO. A logic high on ProReset will cause the NOR gate output (!GateSD) to go low, disabling the gate drivers. Logic Combination . The NOR gate ensures that an overvoltage condition, manual reset, or both will assert a logic low at the !GateSD line, thereby disabling the IR2302 gate drivers and halting PWM inversion. Understanding the state of the !GateSD pin is dictated by the following table: . Table X. NOR Gate Output for !GateSD Based on CompOut and ProReset . | CompOut | ProReset | !GateSD | Gate Driver State | . | 0 | 0 | 1 | Enabled (normal operation) | . | 0 | 1 | 0 | Disabled (manual reset) | . | 1 | 0 | 0 | Disabled (overvoltage) | . | 1 | 1 | 0 | Disabled (both conditions) | . In the case that the shutdown pins of the gate drivers are desired to be controlled independently of the OVRP, it is possible to override this behavior by manually controlling the !GateSD line via software. However, this is not recommended in normal operation, as it bypasses the automatic protection logic. ",
    "url": "/hardware/atinverter_v2/ov_reset_prot_hw.html#functionality-breakdown",
    
    "relUrl": "/hardware/atinverter_v2/ov_reset_prot_hw.html#functionality-breakdown"
  },"115": {
    "doc": "OV and Reset Protection",
    "title": "Simulation",
    "content": "The OVRP circuit was simulated using Falstad, a free online circuit simulator. The interactive simulation can be accessed using the following link. Figure X. Overvoltage and Reset Protection Simulation Circuit . To interact with the simulation: . | Use the Vdc slider to vary the H-bridge DC supply voltage. | Toggle the ProReset switch to simulate the state of the ATMEGA328P GPIO pin that controls manual reset. | . The Vdc overvoltage threshold is configured to 52.5V as previously discussed. When this value is exceeded, !GateSD should trigger low, which disables the gate drivers. ",
    "url": "/hardware/atinverter_v2/ov_reset_prot_hw.html#simulation",
    
    "relUrl": "/hardware/atinverter_v2/ov_reset_prot_hw.html#simulation"
  },"116": {
    "doc": "OV and Reset Protection",
    "title": "OV and Reset Protection",
    "content": ". ",
    "url": "/hardware/atinverter_v2/ov_reset_prot_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/ov_reset_prot_hw.html"
  },"117": {
    "doc": "Power Inverter",
    "title": "Power Inverter Hardware",
    "content": ". The Atinverter V2 power inverter is based on a single phase PWM inverter topology that is software-configurable for either 50Hz or 60Hz output. Pulse-width modulation (PWM) signals are generated by the ATMEGA328P using its hardware PWM pins. This signal is conditioned by a pair of gate drivers before being delivered to the H-bridge topology which converts the control signals into power signals. The resulting waveform is passed through a symmetrical LC filter, rendering a clean 50Hz or 60Hz sinusoidal output for delivery to the load. Figure X. Power Inverter Signal Chain . While the majority of the inverter architecture was carried over from the original Atinverter V1 design, two key hardware modifications were introduced in this iteration: . | Reduced bootstrap capacitor size: Decreased from 4.7‚ÄØ¬µF to 1‚ÄØ¬µF to limit inrush current and enhance switching efficiency. | Higher gate drive voltage: The MOSFETs are now driven at a gate-to-source voltage of 12V instead of 5V, significantly improving conduction efficiency and reducing switching losses. | . As most of the design was previously developed in the Atinverter V1 iteration, a detailed reference can be found in [citation]. Nonetheless, a brief description of each stage of the power inverter is covered. ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#power-inverter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#power-inverter-hardware"
  },"118": {
    "doc": "Power Inverter",
    "title": "„Ä∞Ô∏è PWM Generation",
    "content": "The power inverter operation is catalyzed by the PWM generation from the ATMEGA328P. This MCU generates pulse-width modulated (PWM) square waves at a frequency of 31,372Hz that, when combined with an appropriate switching circuit and filtering stage, can approximate the output of a 50Hz or 60Hz pure sine wave power inverter. While there are other simpler approaches that can be employed to achieve inversion, such as square wave or modified square wave inverters, this one achieves higher levels of waveform fidelity. In other words, this modulation technique allows our output waveform to behave and appear more like a real sine wave. Source: Different Types of AC signals Produced by Inverters . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#%EF%B8%8F-pwm-generation",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#Ô∏è-pwm-generation"
  },"119": {
    "doc": "Power Inverter",
    "title": "üß† Gate Drivers",
    "content": "The next stage in the power signal chain is the gate driver circuit. It performs two main tasks: . | Enabling high-side transistor drive capability in H-bridge through a bootstrap circuitry by level shifting the low-voltage PWM signals from the ATMEGA328P to higher voltages | Enhance current delivery to the power transistors by sourcing gate drive current from an external supply, enabling rapid charging and discharging of gate capacitance for efficient switching. | . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-gate-drivers",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-gate-drivers"
  },"120": {
    "doc": "Power Inverter",
    "title": "üîÅ H-Bridge Topology",
    "content": "Being composed of 4 power transistors that complimentarily switch at a specific frequency, the H-bridge topology is a conventional design that is widely implemented in many pure sine wave inverters. This design enables the connected load to experience a positive and negative voltage swing solely based on switching states, effectively eliminating the need for a negative supply rail. This dual-polarity effect is what allows for the production of a full AC swing across the load and is achieved by PWM control signals as well as only one DC supply. ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-h-bridge-topology",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-h-bridge-topology"
  },"121": {
    "doc": "Power Inverter",
    "title": "üîâ LC Filter",
    "content": "Prior to delivering the power to the load, a low pass filter stage is employed to: . | Remove high frequency content, especially the switching frequency of the PWM signals. | Preserve the fundamental frequency of interest. In our case, our PWM-based inverter is designed for 50 or 60Hz. | . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-lc-filter",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-lc-filter"
  },"122": {
    "doc": "Power Inverter",
    "title": "Power Inverter",
    "content": " ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html"
  },"123": {
    "doc": "Atinverter V1/2 Power Rating",
    "title": "Hardware",
    "content": ". MOSFETs (IRFB4020PBF): . | Continuous Drain Current (ID): 18 A at 25¬∞C | Drain-to-Source Voltage (VDSS): 200 V | Maximum Power Dissipation (PD): 100 W at 25¬∞C | . Inductors (AIRD-02-221K): . | Inductance: 220 ¬µH ‚Äã | Current Rating: . | Continuous: 2.8 A | Saturation: 7 A | . | . Capacitors (1189-4160-1-ND): . | Rated Voltage 250V | Ripple Current @ Low Frequency: 188 mA @ 120 Hz | Ripple Current @ High Frequency: 470 mA @ 100 kHz | . Theoretical max: . | Pmax = Vmax * Imax = 200V * 2.8A = 560W | . BUUUTTTT ‚Äî that‚Äôs theoretical! Needn to consider: . | Need to consider proper heatsinking for the MOSFETs (18 A is at 25¬∞C, derates with temp) | Ripple current through cap &lt; 470mA | Safe design margin: do not run at 100% ratings | Consider switching trajectory | . Reasonably speaking somwhere up to 450W . ",
    "url": "/hardware/power_rating.html#hardware",
    
    "relUrl": "/hardware/power_rating.html#hardware"
  },"124": {
    "doc": "Atinverter V1/2 Power Rating",
    "title": "Atinverter V1/2 Power Rating",
    "content": " ",
    "url": "/hardware/power_rating.html",
    
    "relUrl": "/hardware/power_rating.html"
  },"125": {
    "doc": "PWM Inversion",
    "title": "50/60Hz PWM Inversion Library Feature",
    "content": ". ",
    "url": "/software/library/features/pwm_inversion_feature.html#5060hz-pwm-inversion-library-feature",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#5060hz-pwm-inversion-library-feature"
  },"126": {
    "doc": "PWM Inversion",
    "title": "üìã Overview",
    "content": "This section aims to document the functionality of the Atinverter library‚Äôs PWM generation feature, used to synthesize a sinusoidal waveform using a timer-driven software control scheme. The PWM waveform is composed of high-frequency switching pulses generated by Timer1 interrupts, which step through a precomputed sine lookup table at a rate of 31,372‚ÄØkHz. Simultaneously, Timer0 is configured to Phase Correct PWM mode and alternates the output between two hardware PWM pins to approximate a 50Hz or 60Hz AC signal. The software manages duty cycle updates and pin toggling using ISR logic, ultimately enabling fully software-defined sinusoidal PWM output from the ATMEGA328P. ",
    "url": "/software/library/features/pwm_inversion_feature.html#-overview",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-overview"
  },"127": {
    "doc": "PWM Inversion",
    "title": "üìå Pin Assignments",
    "content": ". Table X. ATMEGA328P Pin Configuration for PWM Control . | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | PWM A Side | PWM_A_PIN | 5 | OUTPUT | . | PWM B Side | PWM_B_PIN | 6 | OUTPUT | . | Gate Shutdown | GATESD_PIN | 8 | INPUT | . | Protection Reset | PRORESET_PIN | 9 | OUTPUT | . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-pin-assignments"
  },"128": {
    "doc": "PWM Inversion",
    "title": "üìÇ Header File Definitions",
    "content": "Implementation in Atinverter.h: . // AC RMS Sampling Period #define MS_PER_SECOND 1000 // PWM Inversion Parameters #define SIN_50HZ_PWM_SIZE 313 #define SIN_60HZ_PWM_SIZE 260 // PWM Pin Definitions const int PWM_A_PIN = 5; const int PWM_B_PIN = 6; const int GATESD_PIN = 8; const int PRORESET_PIN = 9; // Parameters for PWM static bool is50Hz; static int sin_i; static int pwm_i; static int OK; static const int sin50HzPWM[312]; static const int sin60HzPWM[261]; // Methods void startPWM(uint16_t frequency); static void pwmISR(); void enablePWM(); void disablePWM(); . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-header-file-definitions",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-header-file-definitions"
  },"129": {
    "doc": "PWM Inversion",
    "title": "üßÆ 50Hz and 60Hz Sinusoid Lookup Table",
    "content": "// Define the sinusoidal 50Hz sample array (312 points) const int Atinverter::sin50HzPWM[] = { 1,2,5,7,10,12,15,17,19,22,24,27,30,32,34,37,39,42,44,47,49,52,54,57,59,61,64,66, 69,71,73,76,78,80,83,85,88,90,92,94,97,99,101,103,106,108,110,113,115,117,119,121, 124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164, 166,168,169,171,173,175,177,178,180,182,184,185,187,188,190,192,193,195,196,198,199, 201,202,204,205,207,208,209,211,212,213,215,216,217,219,220,221,222,223,224,225,226, 227,228,229,230,231,232,233,234,235,236,237,237,238,239,240,240,241,242,242,243,243, 244,244,245,245,246,246,247,247,247,248,248,248,248,249,249,249,249,249,255,255,255, 255,249,249,249,249,249,248,248,248,248,247,247,247,246,246,245,245,244,244,243,243, 242,242,241,240,240,239,238,237,237,236,235,234,233,232,231,230,229,228,227,226,225, 224,223,222,221,220,219,217,216,215,213,212,211,209,208,207,205,204,202,201,199,198, 196,195,193,192,190,188,187,185,184,182,180,178,177,175,173,171,169,168,166,164,162, 160,158,156,154,152,150,148,146,144,142,140,138,136,134,132,130,128,126,124,121,119, 117,115,113,110,108,106,103,101,99,97,94,92,90,88,85,83,80,78,76,73,71,69,66,64,61, 59,57,54,52,49,47,44,42,39,37,34,32,30,27,24,22,19,17,15,12,10,7,5,2,1}; // Define the sinusoidal 60Hz sample array (261 points) const int Atinverter::sin60HzPWM[] = { 1,3,6,9,12,15,18,21,24,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,73,76,79, 82,85,88,91,93,96,99,102,104,107,110,112,115,118,120,123,126,128,131,133,136,138, 141,143,146,148,151,153,155,158,160,162,165,167,169,171,173,176,178,180,182,184, 186,188,190,192,194,196,197,199,201,203,205,206,208,210,211,213,214,216,217,219, 220,222,223,224,226,227,228,229,230,232,233,234,235,236,237,238,239,239,240,241, 242,243,243,244,244,245,246,246,247,247,247,248,248,248,249,249,249,249,249,249, 249,249,249,249,249,249,248,248,248,247,247,247,246,246,245,244,244,243,243,242, 241,240,239,239,238,237,236,235,234,233,232,230,229,228,227,226,224,223,222,220, 219,217,216,214,213,211,210,208,206,205,203,201,199,197,196,194,192,190,188,186, 184,182,180,178,176,173,171,169,167,165,162,160,158,155,153,151,148,146,143,141, 138,136,133,131,128,126,123,120,118,115,112,110,107,104,102,99,96,93,91,88,85,82, 79,76,73,71,68,65,62,59,56,53,50,47,44,41,38,35,32,29,26,24,21,18,15,12,9,6,3,1}; . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-50hz-and-60hz-sinusoid-lookup-table",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-50hz-and-60hz-sinusoid-lookup-table"
  },"130": {
    "doc": "PWM Inversion",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/pwm_inversion_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-method-descriptions"
  },"131": {
    "doc": "PWM Inversion",
    "title": "void startPWM(uint16_t frequency)",
    "content": "Purpose: Begins PWM and initializes all required timers and registers for 50Hz or 60Hz PWM generation. Pseudocode: . | Disable global interrupts | If the frequency input is not 50Hz or 60Hz . | Set a default frequency of 50Hz | . | Set global frequency mode flag used by pwmISR based on frequency input for sample array selection | Compute the sampling time window used in getRmsAC() and getZeroPoint() | Configure PWM pins as outputs | Set reset logic pin (PRORESET) as output and drive LOW to ensure gate driver is on | Set gate shutdown pin (GATESD) as input to allow logic protection circuitry to control gate drivers | Reset Timer0 control register A, B, and the counter | Set up Timer0 for Phase Correct PWM (8-bit) with no prescaler | Reset Timer1 control register B and the counter | Set compare match value depending on frequency mode flag | Set up Timer1 for CTC mode to trigger the waveform stepping ISR | Enable Timer1 Compare A interrupt | Re-enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::startPWM(uint16_t frequency) { cli(); if (frequency != 50 &amp;&amp; frequency != 60) { frequency = 50; } is50Hz = (frequency == 50); period = MS_PER_SECOND / frequency; pinMode(PWM_A_PIN, OUTPUT); pinMode(PWM_B_PIN, OUTPUT); pinMode(PRORESET_PIN, OUTPUT); digitalWrite(PRORESET_PIN, LOW); pinMode(GATESD_PIN, INPUT); TCCR0A = 0; TCCR0B = 0; TCNT0 = 0; TCCR0A = 0b10100001; TCCR0B = 0b00000001; TCCR1A = is50Hz ? 0b1000010 : 0; TCCR1B = 0; TCNT1 = 0; OCR1A = is50Hz ? 624 : 509; TCCR1B = 0b00001001; TIMSK1 |= (1 &lt;&lt; OCIE1A); sei(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-startpwmuint16_t-frequency",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-startpwmuint16_t-frequency"
  },"132": {
    "doc": "PWM Inversion",
    "title": "static void pwmISR()",
    "content": "Purpose: To generate the alternating sinusoidal PWM signals on the digital pins 5 and 6 by iterating through a lookup table of precomputed PWM values. Pseudocode: . | Select sinusoid lookup table based on frequency mode flag is50Hz | Determine the max index for lookup table based on the frequency mode flag | If the end of the lookup table has been reached and the digital pin flag OK is set LOW (indicates that digital pin 6 is currently active except for first pwmISR() iteration): . | Reset lookup table index and toggle the digital pin flag to activate pin 5 and deactivate pin 6 in the same cycle | . | If the end of the lookup table has been reached and the digital pin flag OK is set HIGH (indicates that digital pin 5 is currently active except for first pwmISR() iteration): . | Reset lookup table index and toggle to digital pin flag to activate pin 6 and deactivate pin 5 in the same cycle | . | Load PWM pulse value from lookup table | Increment the lookup table index sin_i to move to the next sample | If OK flag is off: . | Set digital pin 5 (OCR0B) off | Set digital pin 6 (OCR0A) to output current PWM pulse | . | If OK flag is on: . | Set digital pin 6 (OCR0A) off | Set digital pin 5 (OCR0B) to output current PWM pulse | . | . Implementation in Atinverter.cpp: . void Atinverter::pwmISR() { const int* sinPWM = is50Hz ? sin50HzPWM : sin60HzPWM; int maxIndex = is50Hz ? SIN_50HZ_PWM_SIZE : SIN_60HZ_PWM_SIZE; if (sin_i &gt; maxIndex &amp;&amp; OK == 0) { sin_i = 0; OK = 1; } else if (sin_i &gt; maxIndex &amp;&amp; OK == 1) { sin_i = 0; OK = 0; } pwm_i = sinPWM[sin_i]; sin_i++; if (OK == 0) { OCR0B = 0; OCR0A = pwm_i; } else { OCR0A = 0; OCR0B = pwm_i; } } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#static-void-pwmisr",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#static-void-pwmisr"
  },"133": {
    "doc": "PWM Inversion",
    "title": "void enablePWM()",
    "content": "Purpose: Enables the Timer1 interrupts so that PWM generation resumes. Pseudocode: . | Disable global interrupts | Enable the Timer1 Compare Match A interrupt (OCIE1A) | Re-enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::enablePWM() { cli(); TIMSK1 |= (1 &lt;&lt; OCIE1A); sei(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-enablepwm",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-enablepwm"
  },"134": {
    "doc": "PWM Inversion",
    "title": "void disablePWM()",
    "content": "Purpose: Disables the Timer1 interrupts to stop PWM generation without affecting other global interrupts. Pseudocode: . | Disable global interrupts | Disable the Timer1 Compare Match A interrupt interrupts (OCIE1A) | Re-enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::disablePWM() { cli(); TIMSK1 &amp;= ~(1 &lt;&lt; OCIE1A); sei(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-disablepwm",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-disablepwm"
  },"135": {
    "doc": "PWM Inversion",
    "title": "‚èπÔ∏è ISR Description",
    "content": " ",
    "url": "/software/library/features/pwm_inversion_feature.html#%EF%B8%8F-isr-description",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#Ô∏è-isr-description"
  },"136": {
    "doc": "PWM Inversion",
    "title": "ISR(TIMER1_COMPA_vect)",
    "content": "Purpose: This interrupt service routine (ISR) is triggered at each Timer1 compare match and calls the pwmISR() method to update the output PWM waveform. *Note: A separate static method Atinverter::pwmISR() is used instead of embedding the PWM logic directly inside the ISR(TIMER1_COMPA_vect) since ISRs cannot access instances of a class as they are not tied directly to an object. The PWM parameters is50Hz, sin_i, pwm_i, OK, sin50HzPWM, and sin60HzPWM are based on an instance of the Atinverter class. Pseudocode: . | Call Atinverter::pwmISR() to step through the sinusoidal array samples | . Implementation in Atinverter.cpp: . ISR(TIMER1_COMPA_vect) { Atinverter::pwmISR(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#isrtimer1_compa_vect",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#isrtimer1_compa_vect"
  },"137": {
    "doc": "PWM Inversion",
    "title": "PWM Inversion",
    "content": ". ",
    "url": "/software/library/features/pwm_inversion_feature.html",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html"
  },"138": {
    "doc": "PWM Inversion",
    "title": "50/60Hz PWM Inversion Program Modules",
    "content": ". Purpose: These two standalone programs (50Hz_PWM_Inverter.ino and 60Hz_PWM_Inverter.ino) exhibits how to utilize the Atinverter library‚Äôs PWM generation functionality for the PWM inverter. Each file initializes the PWM for at a switching frequency of 31,372kHz and fundamental frequency of 50Hz or 60Hz, which are required for AC waveform generation. ",
    "url": "/software/modules/pwm_inversion_module.html#5060hz-pwm-inversion-program-modules",
    
    "relUrl": "/software/modules/pwm_inversion_module.html#5060hz-pwm-inversion-program-modules"
  },"139": {
    "doc": "PWM Inversion",
    "title": "50Hz_PWM_Inverter.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create an Atinverter instance | Begin PWM operation at the specified frequency of 50Hz | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; void setup(){ atinverter.startPWM(50); } void loop(){ } . ",
    "url": "/software/modules/pwm_inversion_module.html#50hz_pwm_inverterino",
    
    "relUrl": "/software/modules/pwm_inversion_module.html#50hz_pwm_inverterino"
  },"140": {
    "doc": "PWM Inversion",
    "title": "60Hz_PWM_Inverter.ino",
    "content": "Psuedocode: . | Include the Atinverter library | Create an Atinverter instance | Begin PWM operation at the specified frequency of 60Hz | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; void setup() { atinverter.startPWM(60); } void loop() { } . ",
    "url": "/software/modules/pwm_inversion_module.html#60hz_pwm_inverterino",
    
    "relUrl": "/software/modules/pwm_inversion_module.html#60hz_pwm_inverterino"
  },"141": {
    "doc": "PWM Inversion",
    "title": "PWM Inversion",
    "content": " ",
    "url": "/software/modules/pwm_inversion_module.html",
    
    "relUrl": "/software/modules/pwm_inversion_module.html"
  },"142": {
    "doc": "Scratchpad",
    "title": "Testing",
    "content": "First Term This is the definition of the first term. Second Term This is one definition of the second term. This is another definition of the second term. The world is flat. We now know that the world is round. This sentence uses $ delimiters to show math inline: $\\sqrt{3x-1}+(1+x)^2$ . highlight . X2 . Use `code` in your Markdown file. H20 . I need to highlight these very important words. ",
    "url": "/scratchpad.html#testing",
    
    "relUrl": "/scratchpad.html#testing"
  },"143": {
    "doc": "Scratchpad",
    "title": "Callouts",
    "content": "A paragraph . A paragraph . Another paragraph . The last paragraph . Highlight yellow . Highlight blue . Highlight green . Highlight red . Highlight greylt . Test 2 . A paragraph . A paragraph . Another paragraph . The last paragraph . New title . ‚ÄúWhy not simply use the delay() or millis() functions to accomplish this?‚Äù . ",
    "url": "/scratchpad.html#callouts",
    
    "relUrl": "/scratchpad.html#callouts"
  },"144": {
    "doc": "Scratchpad",
    "title": "Italicizing and Bolding",
    "content": "Lorem ipsum . Lorem ipsum . lorem ipsum . Gone camping! :tent: Be back soon. That is so funny! :joy: . :smile: üòÄ . ",
    "url": "/scratchpad.html#italicizing-and-bolding",
    
    "relUrl": "/scratchpad.html#italicizing-and-bolding"
  },"145": {
    "doc": "Scratchpad",
    "title": "Tables",
    "content": "| head1 | head two | three |:‚Äî‚Äî‚Äî‚Äî-|:‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|:‚Äî‚Äî| ok | good swedish fish | nice | out of stock | good and plenty | nice | ok | good oreos | hmm | ok | good zoute drop | yumm | . ",
    "url": "/scratchpad.html#tables",
    
    "relUrl": "/scratchpad.html#tables"
  },"146": {
    "doc": "Scratchpad",
    "title": "Code  blocks",
    "content": "This is code . const a = 10; static var; . ",
    "url": "/scratchpad.html#code--blocks",
    
    "relUrl": "/scratchpad.html#code--blocks"
  },"147": {
    "doc": "Scratchpad",
    "title": "Creating a Link",
    "content": "Relative link within the directories: This is a link External Link: Arduino Docs . ",
    "url": "/scratchpad.html#creating-a-link",
    
    "relUrl": "/scratchpad.html#creating-a-link"
  },"148": {
    "doc": "Scratchpad",
    "title": "Images",
    "content": ". hey test . oh my . sheesh . The nodes for the library and modules are also interactive‚Äîclick to explore specific software functionality and learn more about its design. ",
    "url": "/scratchpad.html#images",
    
    "relUrl": "/scratchpad.html#images"
  },"149": {
    "doc": "Scratchpad",
    "title": "Putting lines in between",
    "content": "hi . there . ",
    "url": "/scratchpad.html#putting-lines-in-between",
    
    "relUrl": "/scratchpad.html#putting-lines-in-between"
  },"150": {
    "doc": "Scratchpad",
    "title": "Creating an ordered list of items",
    "content": ". | bananas | apples | durian | . ",
    "url": "/scratchpad.html#creating-an-ordered-list-of-items",
    
    "relUrl": "/scratchpad.html#creating-an-ordered-list-of-items"
  },"151": {
    "doc": "Scratchpad",
    "title": "Creating an unordered list of items",
    "content": ". | bananas | apples | durian . | cherries | . | . ",
    "url": "/scratchpad.html#creating-an-unordered-list-of-items",
    
    "relUrl": "/scratchpad.html#creating-an-unordered-list-of-items"
  },"152": {
    "doc": "Scratchpad",
    "title": "Tables",
    "content": "| Col 1 | Col 2 | ‚Äî‚Äì | :‚Äî‚Äì: | . | hello, this is a todo item | hello, this is another todo item | goodbye, this item is done | . graph TD; accTitle: the diamond pattern accDescr: a graph with four nodes: A points to B and C, while B and C both point to D A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; C--&gt;A; D--&gt;E; E--&gt;A; E--&gt;B; . flowchart LR User(circle) --tcp/80 --&gt; LoadBalancer&gt;random shape] --tcp/1337 ---&gt; Webserver{rhombus} . flowchart LR subgraph PublicInternet User end subgraph LoadBalancingZone LoadBalancer end subgraph WebserverZone WebserverA WebserverB end User --tcp/80 --&gt; LoadBalancer LoadBalancer --&gt; WebserverA LoadBalancer --&gt; WebserverB WebserverA --&gt; DatabaseserverA WebserverA -.-&gt; DatabaseserverB WebserverB --&gt; DatabaseserverA WebserverB -.-&gt; DatabaseserverB . pie title A piechart \"SliceA\" : 5 \"SliceB\" : 15 . sankey-beta day, sleep, 8 day, work, 8 day, fun, 2 . A paragraph . Another paragraph . The last paragraph . | Understanding how to communicate between the ADC122S021 and the ATMEGA328P using the SPI protocol for serial transfer of AC voltage data. | . Configuring SPI Protocol . This section describes SPI pins and clock frequency configuration to ensure successful communication. To set the CS, MOSI, and SCLK pins to their desired state, use the following command . #include &lt;SPI.h&gt; . SPI.beginTransaction(SPISettings(1500000, MSBFIRST, SPI_MODE0)); // Configure and start comms . ",
    "url": "/scratchpad.html#tables-1",
    
    "relUrl": "/scratchpad.html#tables-1"
  },"153": {
    "doc": "Scratchpad",
    "title": "üî¢ PWM Timing Calculation (for 50Hz output)",
    "content": "\\(f_{sw} = 31,372Hz\\) \\(f_{sw} = \\frac{1}{f_{sw}} = 31.875\\mu s\\) . ",
    "url": "/scratchpad.html#-pwm-timing-calculation-for-50hz-output",
    
    "relUrl": "/scratchpad.html#-pwm-timing-calculation-for-50hz-output"
  },"154": {
    "doc": "Scratchpad",
    "title": "Inductor Selection",
    "content": "To determine the inductor current (input current draw): . \\[I_{L(DC)} = \\frac{V_{OUT} \\times I_{OUT}}{V_{IN} \\times \\eta}\\] . | $V_{OUT}$ = 12V | $V_{IN}$ = 5V | $\\eta$ = 0.8 (80% recommended by datasheet) | $I_{OUT}$ = ? | . Need to find the load current that will be drawn. This boost converter is only driving the two IR2302 gate drivers for our PWM Inverter H-bridge design so if we find the current consumed by these drivers, we will effectively find the output load to drive. The current consumption of a gate driver is based upon the static and dynamic current consumption. As per the IR2302 datasheet, the max possible Quiescent Vcc supply current $I_{QCC}$ = 1.6mA. Therefore, $I_{static}$ = 1.6mA. The dynamic current consumed by the device can be found by the following relation between the total gate charge of the MOSFET and the switching frequency: . $I_{dynamic}‚Äã = Q_{g} ‚Äã√ó f_{sw}$ . As per the IRFB4020PBF MOSFET datasheet, the maximum total gate charge is 29nC and the switching frequency of operation of the gate drivers is 31,372Hz. | $Q_{g} = 29nC$ | $f_{sw} = 31,372Hz$ | . Using these values, the dynamic current consumption of one MOSFET is: . $I_{dynamic}‚Äã = 0.91mA$ . Considering that the PWM inverter topology is based on 4 MOSFETs with only 2 operating at any given time simultaneously, this means the total dynamic current is $2 \\times I_{dynamic}‚Äã = 1.82mA$. Additionally, the quiescent current is dictated by two gate drivers so the total static current is $2 \\times I_{static}‚Äã = 3.2mA$. $I_{LOAD}‚Äã = I_{STATIC} ‚Äã+ I_{DYNAMIC}$ $I_{OUT}‚Äã = 5.02mA$ . Now that we have the total load current $I_{OUT}$ = 5.02mA, then we can solve for the inductor current using the following values: . | $V_{OUT} = 12V$ | $V_{IN} = 5V$ | $I_{OUT} = 5.02mA$ | $\\eta$ = 0.8 (80% recommended by datasheet) | . \\[I_{L(DC)} = 15.06mA\\] The inductor ripple current is calculated with Equation 3 for an asynchronous boost converter in continuous conduction mode (CCM). \\[\\Delta I_{L(\\text{P-P})} = \\frac{V_{IN} \\times (V_{OUT} + 0.8V - V_{IN})}{L \\times f_{SW} \\times (V_{OUT} + 0.8V)}\\] where: . | ŒîIL(P-P) is inductor ripple current | L is inductor value | f SW is switching frequency | VOUT is output voltage | VIN is input voltage | . ",
    "url": "/scratchpad.html#inductor-selection",
    
    "relUrl": "/scratchpad.html#inductor-selection"
  },"155": {
    "doc": "Scratchpad",
    "title": "Scratchpad",
    "content": " ",
    "url": "/scratchpad.html",
    
    "relUrl": "/scratchpad.html"
  },"156": {
    "doc": "Software",
    "title": "Software",
    "content": ". Atinverter V1 Atinverter V2 . ",
    "url": "/software/software.html",
    
    "relUrl": "/software/software.html"
  },"157": {
    "doc": "Timer 2 Delay",
    "title": "Timer 2 Delay Library Feature",
    "content": ". ",
    "url": "/software/library/features/timer2_delay_feature.html#timer-2-delay-library-feature",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#timer-2-delay-library-feature"
  },"158": {
    "doc": "Timer 2 Delay",
    "title": "üìã Overview",
    "content": "An interface is required to handle program delays for time-sensitive operations such as AC voltage sensing and serial communication, among other tasks. üí≠ ‚ÄúWhy not use the Arduino core functions delay(), millis(), or micros() to accomplish this?‚Äù . Although that might seem like the most straightforward approach, the ATMEGA328P Timer0 ‚Äî used by these core functions ‚Äî is also responsible for PWM generation in our hardware. This is described in detail in the PWM Inversion section. If we attempt to use the core delay functions (which reconfigure Timer0 registers), while simultaneously using Timer0 to handle PWM interrupts, we risk introducing conflicting register states. This also translates to erratic behavior in our PWM output which although may not be catastrophic, it is certainly not desired üòÖ. üí≠ ‚ÄúWhy not create a software-based delay program with an incrementer?‚Äù . unsigned long counter = 0; while (counter &lt; SOME_VALUE) { counter++; } . To implement delay2() and millis2(), it‚Äôs not practical to only rely on a simple software incrementer (e.g., counter++) inside a loop to create timing. This would be an approach that requires trial-and-error tuning of a maximum value to achieve a desired delay. In addition, this is inefficient, non-deterministic, and highly sensitive to compiler optimizations or clock speed changes. ",
    "url": "/software/library/features/timer2_delay_feature.html#-overview",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-overview"
  },"159": {
    "doc": "Timer 2 Delay",
    "title": "üí° The Workaround",
    "content": "To resolve this, we developed custom timing functions ‚Äî delay2() and millis2() ‚Äî based on Timer2 from the ATMEGA328P. These serve as effective substitutes for the Arduino core library timing functions, providing a millisecond-based timing mechanism that operates independently of Timer0. ",
    "url": "/software/library/features/timer2_delay_feature.html#-the-workaround",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-the-workaround"
  },"160": {
    "doc": "Timer 2 Delay",
    "title": "‚è±Ô∏è Understanding the Timers on the ATMEGA328P",
    "content": "The ATMEGA328P includes three timers, each with different bit widths: . | Timer0: 8-bit | Timer1: 16-bit | Timer2: 8-bit | . üí≠ ‚ÄúWhat do the ‚Äòbits‚Äô actually mean?‚Äù . The number of bits determines how high a timer can count before it overflows and restarts. Think of it like a clock: . | An 8-bit timer can count from 0 to 255 ($2^8 - 1$) | A 16-bit timer can count from 0 to 65,535 ($2^{16} - 1$) | . A higher bit-width means higher resolution is possible ‚Äî but for a simple 1ms tick, an 8-bit timer like Timer2 is more than sufficient. ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-understanding-the-timers-on-the-atmega328p",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-understanding-the-timers-on-the-atmega328p"
  },"161": {
    "doc": "Timer 2 Delay",
    "title": "üìÇ Header File Definitions",
    "content": "Implementation in Atinverter.h: . // Timer2 Increment static volatile unsigned long timer2Millis; // Methods void initTimer2Delay(); void delay2(unsigned long ms); unsigned long millis2(); . ",
    "url": "/software/library/features/timer2_delay_feature.html#-header-file-definitions",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-header-file-definitions"
  },"162": {
    "doc": "Timer 2 Delay",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/timer2_delay_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-method-descriptions"
  },"163": {
    "doc": "Timer 2 Delay",
    "title": "void initTimer2Delay()",
    "content": "Purpose: Initializes Timer 2 to generate an interrupt every 1 millisecond. Pseudocode: . | Disable global interrupts | Reset all Timer 2 related registers | Set compare match value for 1ms at 16MHz with 64 prescaler (249) | Set Clear Timer on Compare (CTC) mode | Set pre-scaler to 64 | Enable interrupts on compare match | Enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::initTimer2Delay() { cli(); TCCR2A = 0; TCCR2B = 0; TCNT2 = 0; OCR2A = 249; TCCR2A |= (1 &lt;&lt; WGM21); TCCR2B |= (1 &lt;&lt; CS22); TIMSK2 = (1 &lt;&lt; OCIE2A); sei(); } . ",
    "url": "/software/library/features/timer2_delay_feature.html#void-inittimer2delay",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#void-inittimer2delay"
  },"164": {
    "doc": "Timer 2 Delay",
    "title": "void delay2(unsigned long ms)",
    "content": "Purpose: Pauses execution for a specified duration in milliseconds. Pseudocode: . | Record the current millisecond count from timer2Millis | Continuously check if the elapsed time has reached the specified delay | Exit once the condition is met | . Implementation in Atinverter.cpp: . void Atinverter::delay2(unsigned long ms) { unsigned long start = timer2Millis; while ((timer2Millis - start) &lt; ms) { } } . ",
    "url": "/software/library/features/timer2_delay_feature.html#void-delay2unsigned-long-ms",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#void-delay2unsigned-long-ms"
  },"165": {
    "doc": "Timer 2 Delay",
    "title": "unsigned long millis2()",
    "content": "Purpose: Returns the number of milliseconds elapsed since Timer 2 was initialized. Pseudocode: . | Return the current value of timer2Millis | . Implementation in Atinverter.cpp: . unsigned long Atinverter::millis2() { return timer2Millis; } . ",
    "url": "/software/library/features/timer2_delay_feature.html#unsigned-long-millis2",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#unsigned-long-millis2"
  },"166": {
    "doc": "Timer 2 Delay",
    "title": "‚èπÔ∏è ISR Description",
    "content": " ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-isr-description",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-isr-description"
  },"167": {
    "doc": "Timer 2 Delay",
    "title": "ISR(TIMER2_COMPA_vect)",
    "content": "Purpose: Interrupt Service Routine (ISR) for Timer 2 Compare Match A. It increments a global millisecond counter each time Timer 2 reaches its compare value (every 1ms). Pseudocode: . | Increment the timer2Millis counter | . Implementation in Atinverter.cpp: . ISR(TIMER2_COMPA_vect) { Atinverter::timer2Millis++; } . ",
    "url": "/software/library/features/timer2_delay_feature.html#isrtimer2_compa_vect",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#isrtimer2_compa_vect"
  },"168": {
    "doc": "Timer 2 Delay",
    "title": "‚öôÔ∏è Timer2 Delay Initialization",
    "content": "A thorough analysis on how to configure Timer 2 such that its interrupts fire every 1ms. üí≠ ‚ÄúWhy trigger the interrupts every 1ms? Can‚Äôt you use another time frame?‚Äù . Yes, you can definitely use another time frame, but why would you reasonably do that? Consider these reasons why 1ms interrupts are most appropriate: . | ‚òëÔ∏è Arduino‚Äôs built-in millis() and delay() functions are based on 1ms resolution. | üîÑ Simpler math and high enough resolution (1:1 mapping) . | 500 ticks $\\rightarrow$ count to 500 ticks where each counter tick is 1ms instead of 2000 ticks $\\rightarrow$ count to 2000 ticks where each tick is 0.25ms | . | ‚öôÔ∏è Low CPU Overhead . | Operating the CPU at higher frequency can overwhelm the CPU and be more power intensive | . | . Okay now that I hopefully convinced you of why we need 1ms interrupts, here is how we do it: As per the registers described in pages 127-134 of the ATMEGA328P datasheet, these are what we will need to configure. There are 9 registers in total, but we do not need to configure all of them. The registers of interest and what is needed to do is as follows: . üîß TCCR2A ‚Äì Timer/Counter Control Register A . Reset TCCR2A: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TCCR2A = 0; // Reset Timer2 TCCR2A control register . What It Controls: . | Compare Output Modes COM2A[1:0], COM2B[1:0] ‚Äî what happens to OC2A/OC2B (digital 11/3) pins on compare match with TCNT2 | Waveform Generation Mode WGM2[1:0] ‚Äî selects the timer‚Äôs counting behavior (Normal, PWM/Phase Correct, CTC, or Fast PWM) | . What To Set: . | Clear Timer on Compare Match (CTC) mode using WGM21 bit | . TCCR2A |= (1 &lt;&lt; WGM21); // Set CTC mode . üîß TCCR2B ‚Äì Timer/Counter Control Register B . Reset TCCR2B: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TCCR2B = 0; // Reset Timer2 TCCR2B control register . What It Controls: . | Force Output Compare FOC2B, FOC2A ‚Äî forcing a compare match on OC2B/OC2A (digital 3/11) pins | Waveform Generation Mode WGM22 ‚Äî Used with TCCR2A for CTC or fast PWM | Clock Select CS2[2:0] ‚Äî Sets the pre-scaler for the timer clock source | . What To Set: . | Prescaler of 64 using CS22 bit | . TCCR2B |= (1 &lt;&lt; CS22); // Set prescaler = 64 . üîß TCNT2 ‚Äì Timer/Counter Register . Reset TCNT2: . Starts counter at 0, why would you start anywhere else? üòÖ . TCNT2 = 0; // Reset Timer2 TCNT2 control register . What It Controls: . | Timer Counter 2 TCNT2[7:0] ‚Äî The current value of Timer2‚Äôs counter (0-255) | . What To Set: . | Nothing, the timer runs autonomously | . üîß TIMSK2 ‚Äì Timer/Counter2 Interrupt Mask Register . Reset TIMSK2: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TIMSK2 = 0; // Reset Timer2 TIMSK2 control register . What It Controls: . | Output Compare Match Interrupt Enables OCIE2B, OCIE2A ‚Äî Enables an interrupt when the timer value TCNT2 matches the value in OCR2B or OCR2A. | Waveform Generation Mode TOIE2 ‚Äî Enables an interrupt when timer overflows | . What To Set: . | Enable interrupt on Compare Match A using the OCIE2A bit. | . TIMSK2 = (1 &lt;&lt; OCIE2A); // enable compare interrupt . üîß OCR2A ‚Äì Output Compare Register A . What It Controls: . | Holds the top value the TCNT2 counts up to in CTC mode. | When TCNT2 == OCR2A, an interrupt is fired (if enabled), and the counter resets to 0 on the next tick. | . What To Set: . | OCR2A register to 249 | . OCR2A = 249; . Why Set it To 249: . | This value can be computed based on the equation provided in page 121 of the ATMEGA328P datasheet. | . (1) General CTC equation (when toggling pin): . \\[f_{OCnx} = \\frac{f_{clk_{I/O}}}{2 \\times N \\times (1 + OCRnx)}\\] where: . | $OCRnx$ is the output compare register value | $f_{OCnx}$ is the output frequency of the timer/counter | $f_{clk_{I/O}}$ Clock input frequency (16 MHz for ATmega328P) | N is the timer prescale factor (1, 8, 32, 64, 128, 256, or 1024) | ‚Äú2‚Äù in denominator only needed when toggling a pin to generate a waveform | . üîçImportant Note: In interrupt-only CTC mode (no pin toggling), the ‚Äú2‚Äù in the denominator is not included because the interrupt occurs once per timer cycle. Hence, this constant can be ignored. (2) CTC Interrupt-Only Frequency Equation: . \\[f_{OCnx} = \\frac{f_{clk_{I/O}}}{ N \\times (1 + OCRnx)}\\] Now, we can solve for the OCR2A value that produces an interrupt at a frequency of 1kHz (1ms period) by restructuring this equation. (3) CTC Interrupt-Only OCR2A Equation: . \\[OCRnx = \\frac{f_{clk_{I/O}}}{N \\times f_{OCnx}} - 1\\] üî¢ Solving for OCR2A: . \\[OCRnx = \\frac{16*10^6}{64 \\times 1000} - 1 = 249\\] ‚úÖ Result: . Setting OCR2A = 249 results in 1ms timer interrupts using a 16 MHz clock and a prescaler of 64. And we are done! Those are all the registers you need to set. Now when you look at the Timer 2 register initialization, it should now make more sense üòä . ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-timer2-delay-initialization",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-timer2-delay-initialization"
  },"169": {
    "doc": "Timer 2 Delay",
    "title": "Timer 2 Delay",
    "content": ". ",
    "url": "/software/library/features/timer2_delay_feature.html",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html"
  },"170": {
    "doc": "To-Do",
    "title": "TO-DO",
    "content": ". | Order NOR gate and verify that logic protection circuitry is operational | Verify that schematic, PCB, and 3D model is not missing anything (run DRC again just in case) | Load testing captures | Update UML diagram | Update the Vision section, too sparse right now | Modify DC voltage diagram to include full view of power inverter | . ",
    "url": "/todo.html#to-do",
    
    "relUrl": "/todo.html#to-do"
  },"171": {
    "doc": "To-Do",
    "title": "To-Do",
    "content": " ",
    "url": "/todo.html",
    
    "relUrl": "/todo.html"
  },"172": {
    "doc": "Vision",
    "title": "Vision",
    "content": " ",
    "url": "/vision.html",
    
    "relUrl": "/vision.html"
  },"173": {
    "doc": "Vision",
    "title": "Microgrid Significance",
    "content": "Electricity traverses through a large network of interconnected transmission or distribution systems known as the power grid. With the ever-growing demand for electricity and reliable power grid consumption, grid congestion has been a more prominent phenomenon. This occurs when the power grid is unable to deliver the required power to meet demand, particularly from urban area or high demand loads. To alleviate stress on the power grid, microgrids, which are smaller localized electrical systems, can be employed. A microgrid can operate independently or in sync with the main grid and can supply power during power outages. ",
    "url": "/vision.html#microgrid-significance",
    
    "relUrl": "/vision.html#microgrid-significance"
  },"174": {
    "doc": "Vision",
    "title": "EV Inspired PDA Microgrid and Open Source Platforms",
    "content": "As Electric Vehicle (EV) infrastructure continues to develop and gain wider global acceptance, there is growing motivation not only to utilize these systems for transportation but, more importantly, to harness their microgrid capabilities. To more clearly understand this concept, we can consider a power distribution architecture (PDA) for EVs that can: . | intelligently transact power with the grid, | provide important grid-forming and grid-supporting services | share power in a peer-to-peer fashion with other EVs | act as a standalone microgrid that can interface with external AC and DC sources and loads. | operate and communicate between various open source power converters | . Needs to be updated, will write more in this section, but right now giving emphasis to hardware and software documentation!! . ",
    "url": "/vision.html#ev-inspired-pda-microgrid-and-open-source-platforms",
    
    "relUrl": "/vision.html#ev-inspired-pda-microgrid-and-open-source-platforms"
  }
}
