{"0": {
    "doc": "St. Thomas Inverter Specs",
    "title": "University of St. Thomas Specifications",
    "content": ". mindmap root((Power Inverter Specifications)) **Ratings** Power Rating: 200W Output Voltage: 120V Input Voltage: 12V DC / 24V DC Frequency: 60Hz **Droop Control** Frequency Droop: 60Hz to 57.6Hz at full load Voltage Droop: 120V to 115.2V at full load **Protection Features** Overload Protection Short Circuit Protection Over/Under Voltage Protection Thermal Shutdown **Cooling** Passive cooling with Aluminum sinks **Application** Educational Kits: 3 Kits for K-12 Program Research Kit: 1 Kit developed by UST . ",
    "url": "/hardware/ST_HW.html#university-of-st-thomas-specifications",
    
    "relUrl": "/hardware/ST_HW.html#university-of-st-thomas-specifications"
  },"1": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Ratings",
    "content": ". | Power Rating: 200W | Output Voltage: 120V | Input voltage: 12V DC/24V DC | Frequency: 60Hz | . ",
    "url": "/hardware/ST_HW.html#ratings",
    
    "relUrl": "/hardware/ST_HW.html#ratings"
  },"2": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Droop Control",
    "content": ". | Frequency Droop: 60Hz to 57.6 Hz at full load | Voltage Droop: 120V ‚Äì 115.2V at full load | . ",
    "url": "/hardware/ST_HW.html#droop-control",
    
    "relUrl": "/hardware/ST_HW.html#droop-control"
  },"3": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Protection Features",
    "content": ". | Overload Protection | Short Circuit Protection | Over/Under Voltage Protection | Thermal Shutdown | . ",
    "url": "/hardware/ST_HW.html#protection-features",
    
    "relUrl": "/hardware/ST_HW.html#protection-features"
  },"4": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Cooling",
    "content": ". | Passive cooling with Aluminum sinks | . ",
    "url": "/hardware/ST_HW.html#cooling",
    
    "relUrl": "/hardware/ST_HW.html#cooling"
  },"5": {
    "doc": "St. Thomas Inverter Specs",
    "title": "Application",
    "content": ". | 3 Educational kits for k-12 program enclosed in a shield/box with access to inputs, outputs, and Arduino port | 1 Research kit that will be developed by UST | . ",
    "url": "/hardware/ST_HW.html#application",
    
    "relUrl": "/hardware/ST_HW.html#application"
  },"6": {
    "doc": "St. Thomas Inverter Specs",
    "title": "St. Thomas Inverter Specs",
    "content": " ",
    "url": "/hardware/ST_HW.html",
    
    "relUrl": "/hardware/ST_HW.html"
  },"7": {
    "doc": "Atinverter V1 Hardware",
    "title": "Atinverter V1 Hardware",
    "content": ". The website focuses on the documentation of the Atinverter V2, but to learn more about the hardware design and implementation for the Atinverter V1, please refer to the Atinverter V1 Report. ",
    "url": "/hardware/a_v1_hw.html",
    
    "relUrl": "/hardware/a_v1_hw.html"
  },"8": {
    "doc": "Atinverter V1 Software",
    "title": "Atinverter V1 Software",
    "content": ". The website focuses on the documentation of the Atinverter V2, but to learn more about the software design and implementation for the Atinverter V1, please refer to the Atinverter V1 Report. ",
    "url": "/software/a_v1_sw.html",
    
    "relUrl": "/software/a_v1_sw.html"
  },"9": {
    "doc": "Atinverter V2 Hardware",
    "title": "Atinverter V2 Hardware",
    "content": ". The Atinverter Version 2 (V2) incorporates a multitude of subsystems that work in tandem to support the board‚Äôs main function as a power inverter. A power inverter, not to be confused with a digital logic inverter, is a type of converter that takes a DC signal and transforms it to an AC signal. üí≠ ‚ÄúWhy Atinverter?‚Äù . With the aim of highlighting the relationship between the ATMEGA328P MCU and the power inverter circuitry, the name is based on: ‚ÄúATMEGA328P‚Äù + ‚ÄúInverter‚Äù = ‚ÄúAtinverter‚Äù . To better visualize the core components and the interconnections of the design, consider the following diagram: . Figure X. Atinverter High Level Block Diagram . ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html#atinverter-v2-hardware",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html#atinverter-v2-hardware"
  },"10": {
    "doc": "Atinverter V2 Hardware",
    "title": "Systems",
    "content": "To better understand the full scope of the Atinverter V2, it‚Äôs helpful to explore the various systems in more detail. Click on each section to dive deeper into how each subsystem contributes to the overall design. | üîå Power Inverter | üí° LED Blinking | üìü DC Voltage Sensing | üìü DC Current Sensing | üìü AC Voltage Sensing | üìü AC Current Sensing | üîÅ Inter-Board Communication | üîº Boost Converter | üîΩ Buck Converter | . ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html#systems",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html#systems"
  },"11": {
    "doc": "Atinverter V2 Hardware",
    "title": "Atinverter V2 Hardware",
    "content": " ",
    "url": "/hardware/atinverter_v2/a_v2_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/a_v2_hw.html"
  },"12": {
    "doc": "Atinverter V2 Software",
    "title": "Atinverter V2 Software",
    "content": ". The Atinverter V2 codebase is composed of a Library folder as well as well various module folders (Blink, Main, PWM_Inverting, and VI_Sensing). The Atinverter library contains the object-oriented coding framework that allows for intuitive intialization, control, and sensing of the Atinverter V2 hardware. The various ready-to-run and deployable modules serve the purpose of showcasing the different features of the hardware by incorporating and applying the Atinverter library. The following diagram provides a visual representation of the software hierarchy and the available C++ and Arduino .ino files that the user can utilize to enable Atinverter V2 hardware operation. graph LR; %% Node Definitions A(**software**) style A fill:skyblue,stroke:white,stroke-width:2px B(**Blink**) style B fill:skyblue,stroke:white,stroke-width:2px C(**Library**) style C fill:skyblue,stroke:white,stroke-width:2px D(**Main**) style D fill:skyblue,stroke:white,stroke-width:2px E(**PWM_Inverting**) style E fill:skyblue,stroke:white,stroke-width:2px F(**VI_Sensing**) style F fill:skyblue,stroke:white,stroke-width:2px G(**Blink.ino**) style G fill:skyblue,stroke:white,stroke-width:2px H(**Atinverter.cpp**) style H fill:skyblue,stroke:white,stroke-width:2px I(**Atinverter.h**) style I fill:skyblue,stroke:white,stroke-width:2px J(**Main.ino**) style J fill:skyblue,stroke:white,stroke-width:2px K(**50Hz_PWM_Inverter.ino**) style K fill:skyblue,stroke:white,stroke-width:2px L(**60Hz_PWM_Inverter.ino**) style L fill:skyblue,stroke:white,stroke-width:2px M(**Vdc_Sensing.ino**) style M fill:skyblue,stroke:white,stroke-width:2px N(**Idc_Sensing.ino**) style N fill:skyblue,stroke:white,stroke-width:2px O(**Vac_Sensing.ino**) style O fill:skyblue,stroke:white,stroke-width:2px P(**Iac_Sensing.ino**) style P fill:skyblue,stroke:white,stroke-width:2px %% Node Connections A --&gt; B A --&gt; C A --&gt; D A --&gt; E A --&gt; F B --&gt; G C --&gt; H C --&gt; I D --&gt; J E --&gt; K E --&gt; L F --&gt; M F --&gt; N F --&gt; O F --&gt; P %% Change color of arrow heads %%{init: {'themeVariables': {'lineColor': 'white'}}}%% %% Apply color to the arrows %% 0: 1st arrow (A --&gt; B) 1: 2nd arrow (A --&gt; C) 2: 3rd arrow (A --&gt; D) 3: 4th arrow (A --&gt; E) 4: 5th arrow (A --&gt; F) linkStyle 0 stroke:white, stroke-width:3px; linkStyle 1 stroke:white, stroke-width:3px; linkStyle 2 stroke:white, stroke-width:3px; linkStyle 3 stroke:white, stroke-width:3px; linkStyle 4 stroke:white, stroke-width:3px; %% 5: 6th arrow (B --&gt; G) linkStyle 5 stroke:white, stroke-width:3px; %% 6: 7th arrow (C --&gt; H) 7: 8th arrow (C --&gt; I) linkStyle 6 stroke:white, stroke-width:3px; linkStyle 7 stroke:white, stroke-width:3px; %% 8: 9th arrow (D --&gt; J) linkStyle 8 stroke:white, stroke-width:3px; %% 9: 10th arrow (E --&gt; K) 10: 11th arrow (E --&gt; J) linkStyle 9 stroke:white, stroke-width:3px; linkStyle 10 stroke:white, stroke-width:3px; %% 11: 12th arrow (F --&gt; M) 12: 13th arrow (F --&gt; N) 13: 14th arrow (F --&gt; O) 14: 15th arrow (F --&gt; P) linkStyle 11 stroke:white, stroke-width:3px; linkStyle 12 stroke:white, stroke-width:3px; linkStyle 13 stroke:white, stroke-width:3px; linkStyle 14 stroke:white, stroke-width:3px; . Figure X. Atinverter V2 Software Modules and Files . ",
    "url": "/software/a_v2_sw.html#atinverter-v2-software",
    
    "relUrl": "/software/a_v2_sw.html#atinverter-v2-software"
  },"13": {
    "doc": "Atinverter V2 Software",
    "title": "Atinverter V2 Software",
    "content": ". ",
    "url": "/software/a_v2_sw.html",
    
    "relUrl": "/software/a_v2_sw.html"
  },"14": {
    "doc": "AC Current Sensing",
    "title": "AC Current Sensing Hardware",
    "content": ". Sensing the current from the AC load is similarly achieved to sensing the DC input. On the AC side, the TMCS1108 hall-effect current sensor is likewise employed. What differs is how the signal is analyzed after being sampled by current sensor. In this case, the output analog voltage that maps to the load current is not being delivered directly to ATMEGA328P for processing and calculation, but rather to the second input channel of the ADC122S021. Figure X. AC Current Sensing Block Diagram . To gain more insight into how the algorithm for computing the AC load current is performed using the ADC122S021 sampling, please refer to the section on AC Current Sensing. ",
    "url": "/hardware/atinverter_v2/ac_curr_sensing_hw.html#ac-current-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/ac_curr_sensing_hw.html#ac-current-sensing-hardware"
  },"15": {
    "doc": "AC Current Sensing",
    "title": "AC Current Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/ac_curr_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/ac_curr_sensing_hw.html"
  },"16": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing Library Feature",
    "content": ". ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#ac-vi-sensing-library-feature",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#ac-vi-sensing-library-feature"
  },"17": {
    "doc": "AC V/I Sensing",
    "title": "üìã Overview",
    "content": "The AC Voltage and Current Sensing feature enables real-time monitoring of the PWM inverter‚Äôs output voltage and current. It leverages the ATMEGA328P‚Äôs SPI peripheral to interface with the ADC122S021 which samples conditioned analog signals. This feature includes methods for configuring the SPI bus, acquiring ADC readings, correcting DC offset, computing RMS values, and setting the sensitivity factor that scales the AC RMS readings. As mentioned in the AC Voltage Sensing hardware section, to achieve AC RMS voltage measurement across the load of the power inverter ($V_{\\mathrm{AC_load}}$), the signal is: . | Transformed from a 12V-48$V_{pk}$ AC signal to a composite signal containing both DC and AC components. | Scaled down to a 2.5V DC, 0-1V AC peak signal (effectively ranges from 1.5V to 3.5V), to maintain compatibility with the ADC122S021 input channels | . Now that this signal is conditioned appropriately for sampling, the next step is properly configure the SPI bus on the ATMEGA328P to interface with the ADC122S021. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-overview",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-overview"
  },"18": {
    "doc": "AC V/I Sensing",
    "title": "üîÑ Outline of SPI Communication",
    "content": "The ATMEGA328P operates as the master/controller and the ADC122S021 as the slave/peripheral. As it is conventional in SPI communication, the ATMEGA328P initiates communication by setting CS low. The communication is conducted in 16 clock pulses of the SCLK frequency, corresponding to two byte data frames. Since SPI inherently is full-duplex, these two data frames are used for: . | Sending control data through MOSI (DIN of ADC122S021) to specify the channel to read from | Receiving conversion data through MISO (DOUT of ADC122S021) | . It should be highlighted that the only useful data for DIN and DOUT are the first 8 most significant bits (MSB) and the last 12 least significant bits (LSB) respectively. The ADC122S021 uses a successive approximation register (SAR) topology with a track-and-hold mechanism. The voltage samples are tracked for the first 4 clock cycles and held for data transmission during the subsequent 12 clock cycles. Once the 12-bit conversion data is received by the ATMEGA328P, the CS line is enabled high to terminate communication with the ADC122S021. The timing diagram of the ADC122S021 provides an insightful visual representation of the SPI communication and reflects the information covered. . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-outline-of-spi-communication",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-outline-of-spi-communication"
  },"19": {
    "doc": "AC V/I Sensing",
    "title": "‚åö Choosing the Appropriate SPI Clock Source",
    "content": "Ensuring suitable communication with the ADC122S021 relies on providing a clock source from the ATMEGA328P that falls within the allowable frequency range of the device. The clock signal is critical as it maps to the sampling rate of the ADC122S021 which is also constrained to a specific range. The table below summarizes the ranges of allowable clock frequencies and their corresponding sample rates: . | Notation | Parameter | Range | . | $f_{sclk}$ | Clock Frequency | 0.8MHz - 3.2MHz | . | $f_{s}$ | Sample Rate | 50ksps - 200ksps | . The relationship between the sample rate and the clock frequency can be understood from the following equation: . \\[f_{s} = \\frac{f_{SCLK}}{16}\\] This expression reflects the idea that a complete 12-bit signal conversion requires 16 clock pulses. As a result, the sampling frequency is one-sixteenth of the clock frequency. The clock source delivered to the ADC122S021 is derived from the 16MHz main clock of the ATMEGA328P and a pre-scaler value of our choosing. The available pre-scalers are displayed below: . | Prescaler | Arduino Command | Resulting Frequency | . | 2 | SPI_CLOCK_DIV2 | 8 MHz | . | 4 | SPI_CLOCK_DIV4 | 4 MHz | . | 8 | SPI_CLOCK_DIV8 | 2 MHz | . | 16 | SPI_CLOCK_DIV16 | 1 MHz | . | 32 | SPI_CLOCK_DIV32 | 500 kHz | . | 64 | SPI_CLOCK_DIV64 | 250 kHz | . | 128 | SPI_CLOCK_DIV128 | 125 kHz | . Given that the clock signal is constrained to the range of 0.8MHz - 3.2MHz for the ADC122S021, this means we can choose to either to supply a 1MHz or 2MHz clock signal from the ATMEGA328P. Either option is in theoretically valid, but there are important tradeoffs to consider: . Choosing a higher sampling frequency (2MHz): . | Better resolution | Improved signal to noise ratio (SNR) | Spreading of ADC quantization noise over a broader bandwidth | . Choosing a lower sampling frequency (1MHz): . | Reduced software overhead (fewer clock cycles) | Less memory intensive for MCU | More power efficient | . The Nyquist Sampling Theorem states that to minimally reconstruct an analog signal without aliasing, the sampling frequency $f_{s}$ must be at least 2 times the maximum frequency component $f_{max}$ of the analog signal. This miminum requirement for the sampling rate is also known as the Nyquist Rate. \\[f_{s} \\geq 2 \\times f_{max}\\] Aliasing represents an adverse effect where the sampled waveform loses its charateristic shape and appears as a different frequency. While just marginally satisfying the Nyquist Rate condition may be appropriate in some applications, this does not always guarentee proper resolution and amplitude accuracy of the signal. In practical applications such as sampling sinusoidal signals, it is recommended that $f_{s}$ is at least 5 to 10 times the sinusoidal signal $f_{sinusoid}$. Higher ADC sample rates yield finer resolution in the digitized sinusoidal waveform, whereas lower sampling raters result in a degraded signal in terms of resolution and signal shape. In this design, the ADC122S021 is tasked with sampling the output voltage and current signals of PWM inverter, both of which are 50Hz or 60Hz sinusoidal signals depending on the PWM generation technique. Considering how these signals are far lower in frequency relative to the sampling capabilities of the ADC122S021, a clock rate of 1MHz (pre-scaler 16) was selected. This aims to reduce software overhead and memory load as well as maintain an adequate sampling rate for proper signal digitization. \\[f_{s} = \\frac{1 \\times 10^6Hz}{16} = 62.5kHz\\] \\[\\frac{f_{s}}{f_{max}} = \\frac{62.5 \\times 10^3Hz}{60Hz} ‚âà 1042\\] The sampling frequeny is substantially larger than the recommended amount so a high fidelity signal is to be expected. Translating this concept into software, the command below: . SPI.beginTransaction(SPISettings(CLOCK_FREQUENCY, MSBFIRST, SPI_MODE0)); . is used to specify key metrics of the SPI communication protocol. The CLOCK_FREQUENCY is a macro that maps to 1MHz. In addition, most significant bit (MSB) transmission and SPI Mode 0 (CPOL = 0, CPHA = 0) are specified with macros in accordance with ADC122S021 device requirements. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-choosing-the-appropriate-spi-clock-source",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-choosing-the-appropriate-spi-clock-source"
  },"20": {
    "doc": "AC V/I Sensing",
    "title": "üìå Pin Assignments",
    "content": "The following table delineates the pins used for the SPI protocol and their desired states: . | Pin Type | Digital Pin Number | State | . | CS | 10 | OUTPUT | . | MOSI | 11 | OUTPUT | . | MISO | 12 | INPUT | . | SCLK | 13 | OUTPUT | . Configuring all SPI pins on the ATMEGA328P can be performed by using SPI.begin() from the Arduino built-in SPI.h library. Since the SPI.h library is included in the user-defined header file Atinverter.h, no need to include it separately in the module program. ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-pin-assignments"
  },"21": {
    "doc": "AC V/I Sensing",
    "title": "üìÇ Library Structure",
    "content": "Implementation in Atinverter.h: . #include &lt;SPI.h&gt; // TMCS1108 Current Sensor Parameters #define SENSOR_GAIN_MV_PER_A 400.0f #define MV_TO_V 1000.0f #define VOUT_0A 2.5f // ADC Parameters #define VREF 5.0f #define ADC_122S021_MAX_VALUE 4095.0f // Parameters AC Sensing uint32_t period; float sensitivity = DEFAULT_SENSITIVITY; // AC Voltage and Current Pin Definitions static const int VI_AC_CS_PIN = 10; static const int VI_AC_MOSI_PIN = 11; static const int VI_AC_MISO_PIN = 12; static const int VI_AC_SCLK_PIN = 13; // Methods void setUpSPI(); void setSensitivity(float value); int getADC(uint8_t control_byte); int getZeroPoint(uint8_t control_byte); float getRmsAC(uint8_t loopCount, bool isVac); . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-library-structure",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-library-structure"
  },"22": {
    "doc": "AC V/I Sensing",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#-method-descriptions"
  },"23": {
    "doc": "AC V/I Sensing",
    "title": "void setUpSPI()",
    "content": "Purpose: Initializes the SPI interface and configures the relevant pins. Pseudocode: . | Configure CS, MOSI, and SCLK pins to their desired state | . Implementation in Atinverter.cpp: . void Atinverter::setUpSPI() { SPI.begin(); } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#void-setupspi",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#void-setupspi"
  },"24": {
    "doc": "AC V/I Sensing",
    "title": "int getZeroPoint(uint8_t control_byte)",
    "content": "Purpose: Calculates the zero-point (DC offset) value of the ADC readings over a full sampling period. This value is used to remove the DC bias from the AC signal before performing RMS calculations. Parameters: . | control_byte ‚Äì ADC command byte: 0x00 selects channel 1; 0x08 selects channel 2 | . Pseudocode: . | Initialize accumulators and timing | While the elapsed time is less than the period: . | Read the ADC value from the specified control_byte channel | Accumulate the ADC value | Increment the measurement count | . | Return . | Compute and return the average (sum divided by the count) | . | . Implementation in Atinverter.cpp: . int Atinverter::getZeroPoint(uint8_t control_byte) { uint32_t Vsum = 0; uint32_t measurements_count = 0; uint32_t t_start = this-&gt;millis2(); while (this-&gt;millis2() - t_start &lt; period) { Vsum += this-&gt;getADC(control_byte); measurements_count++; } return Vsum / measurements_count; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#int-getzeropointuint8_t-control_byte",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#int-getzeropointuint8_t-control_byte"
  },"25": {
    "doc": "AC V/I Sensing",
    "title": "void setSensitivity(float value)",
    "content": "Purpose: Sets the sensitivity factor used to scale RMS ADC values to real-world signal amplitude. The sensitivity factor is applied in the getRmsAC() method after calculating the RMS value of the ADC samples. It ensures that the returned value reflects the actual physical signal magnitude, not just the ADC voltage level. Pseudocode: . | Take the user-defined sensitivity input. | Store it as the internal sensitivity scaling variable. | . Implementation in Atinverter.cpp: . void Atinverter::setSensitivity(float value) { sensitivity = value; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#void-setsensitivityfloat-value",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#void-setsensitivityfloat-value"
  },"26": {
    "doc": "AC V/I Sensing",
    "title": "int getADC(uint8_t control_byte)",
    "content": "Purpose: Initiates an SPI transaction with the ADC122S021 to retrieve a 12-bit digital conversion result from the specified input channel. Parameters: . | control_byte ‚Äì ADC command byte: 0x00 selects channel 1; 0x08 selects channel 2 | . Pseudocode: . | Pull CS low and configure SPI parameters to begin SPI transmission | Conduct 1st byte transfer . | Send control byte to specify channel | Receive 8 MSB conversion bits (only 4 LSB are significant) | . | Shift first 8 bits received by 8 bits to make that MSB data | Conduct a 2nd byte transfer . | Send dummy byte (0x00) | Receive 8 LSB bits of conversion | . | Combine the 2 received bytes (MSB + LSB) | Mask the lower 12 bits to get valid ADC data | Pull CS high to end transaction | Return 12-bit ADC sample | . Implementation in Atinverter.cpp: . int Atinverter::getADC(uint8_t control_byte) { digitalWrite(VI_AC_CS_PIN, LOW); SPI.beginTransaction(SPISettings(CLOCK_FREQUENCY, MSBFIRST, SPI_MODE0)); uint16_t data = SPI.transfer(control_byte); data &lt;&lt;= 8; data |= SPI.transfer(0x00); digitalWrite(VI_AC_CS_PIN, HIGH); SPI.endTransaction(); data &amp;= 0x0FFF; return data; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#int-getadcuint8_t-control_byte",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#int-getadcuint8_t-control_byte"
  },"27": {
    "doc": "AC V/I Sensing",
    "title": "float getRmsAC(uint8_t loopCount, bool isVac)",
    "content": "Purpose: Calculates the RMS value of either AC voltage or current over multiple user-defined sampling cycles. The value is offset-corrected using the zero-point and scaled using a sensitivity factor to reflect the actual signal amplitude. Parameters: . | loopCount ‚Äì number of sampling cycles to average over for increased accuracy | isVac ‚Äì true to measure AC voltage; false to measure AC current | . Pseudocode: . | Determine the ADC channel based on isVac . | true to use voltage channel | falseto use current channel | . | Iterate loopCount times: . | Compute DC offset using getZeroPoint() | Initialize accumulators and timing | While elapsed time is less than the period: | . | Sample ADC | Remove DC offset and square the result | Accumulate the sum and measurement count | Compute RMS value using the root mean square formula: $X_{RMS} = \\sqrt{\\frac{1}{N} \\sum x^2}$ | Scale result using sensitivity to convert to physical units | . | Average all loop results and return the final RMS value | . Implementation in Atinverter.cpp: . float Atinverter::getRmsAC(uint8_t loopCount, bool isVac) { uint8_t control_byte; if (isVac){ control_byte = VAC_ADC_CHANNEL; } else{ control_byte = IAC_ADC_CHANNEL; } double readingVoltage = 0.0f; for (uint8_t i = 0; i &lt; loopCount; i++) { int zeroPoint = this-&gt;getZeroPoint(control_byte); int32_t Vnow = 0; uint32_t Vsum = 0; uint32_t measurements_count = 0; uint32_t t_start = this-&gt;millis2(); while (this-&gt;millis2() - t_start &lt; period) { Vnow = this-&gt;getADC(control_byte) - zeroPoint; Vsum += (Vnow * Vnow); measurements_count++; } readingVoltage += sqrt(Vsum / measurements_count) / ADC_122S021_MAX_VALUE * VREF * sensitivity; } return readingVoltage / loopCount; } . ",
    "url": "/software/library/features/ac_vi_sensing_feature.html#float-getrmsacuint8_t-loopcount-bool-isvac",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html#float-getrmsacuint8_t-loopcount-bool-isvac"
  },"28": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing",
    "content": ". ",
    "url": "/software/library/features/ac_vi_sensing_feature.html",
    
    "relUrl": "/software/library/features/ac_vi_sensing_feature.html"
  },"29": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing Module Program",
    "content": ". Purpose: These two standalone programs (Vac_Sensing.ino and Iac_Sensing.ino) demonstrate how to use the Atinverter library‚Äôs AC sensing features to measure either the RMS voltage or RMS current output of the PWM inverter. Both modules validate correct SPI communication with the ADC122S021, PWM generation for inverter operation, signal processing using the root mean square (RMS) method, and employ the Timer 2 based delaying feature. ",
    "url": "/software/modules/ac_vi_sensing_program.html#ac-vi-sensing-module-program",
    
    "relUrl": "/software/modules/ac_vi_sensing_program.html#ac-vi-sensing-module-program"
  },"30": {
    "doc": "AC V/I Sensing",
    "title": "Vac_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance set to 50Hz or 60Hz mode | Initialize the serial monitor for displaying AC voltage readings | Set sensitivity factor that scales the AC RMS readings | Set up SPI interface and associated pins | Begin PWM operation at 50Hz or 60Hz mode | Initialize Timer 2 for time-based delay functionality | Continuously read the averaged output AC voltage | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" #define LOOP_RUNS 20 Atinverter atinverter(60); void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Output AC Voltage Sensing.\")); atinverter.setSensitivity(SENSITIVITY); atinverter.setUpSPI(); atinverter.startPWM(false); atinverter.initTimer2Delay(); } void loop() { float Vac_RMS = atinverter.getRmsAC(true, LOOP_RUNS); Serial.print(F(\"Vac(RMS): \")); Serial.print(Vac_RMS); Serial.println(\"V\"); atinverter.delay2(2000); } . ",
    "url": "/software/modules/ac_vi_sensing_program.html#vac_sensingino",
    
    "relUrl": "/software/modules/ac_vi_sensing_program.html#vac_sensingino"
  },"31": {
    "doc": "AC V/I Sensing",
    "title": "Iac_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance set to 50Hz or 60Hz mode | Initialize the serial monitor for displaying AC current readings | Set sensitivity factor that scales the AC RMS readings | Set up SPI interface and associated pins | Begin PWM operation at 50Hz or 60Hz mode | Configure Timer 2 registers to enable delaying using delay2 method | Continuously read the averaged output AC current | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" #define LOOP_RUNS 20 // Atinverter class instance Atinverter atinverter(60); void setup() { // Initialize Serial Monitor Serial.begin(9600); Serial.println(F(\"Initialize Output AC Voltage Sensing.\")); atinverter.setSensitivity(SENSITIVITY); atinverter.startPWM(false); // 60Hz, true 50Hz atinverter.setUpSPI(); // Configures SCK, CS, and MOSI to outputs atinverter.initTimer2Delay(); // Set up Timer2 registers to proper init values } void loop() { float Iac_RMS = atinverter.getRmsAC(false, LOOP_RUNS); // true = Vac, false = Iac, 20 Serial.print(F(\"Iac(RMS): \")); Serial.print(Iac_RMS); Serial.println(\"A\"); atinverter.delay2(2000); } . ",
    "url": "/software/modules/ac_vi_sensing_program.html#iac_sensingino",
    
    "relUrl": "/software/modules/ac_vi_sensing_program.html#iac_sensingino"
  },"32": {
    "doc": "AC V/I Sensing",
    "title": "AC V/I Sensing",
    "content": " ",
    "url": "/software/modules/ac_vi_sensing_program.html",
    
    "relUrl": "/software/modules/ac_vi_sensing_program.html"
  },"33": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing Hardware",
    "content": ". To achieve the sensing of the AC voltage at the output of the power inverter, the approach is more involved than the DC voltage sensing methodology. Not only does a step down mechanism need to be implemented to provide a low power sensed signal to a processing device, but also a method to handle or correct for the the bipolar nature of the AC wave, namely the negative swing. More specifically, the AC voltage sensing network needs to be able to scale a 12V-48Vpk signal to 0-5V signal in order to be compatible with the ADC122S021, which is used for output voltage and current sampling. The ADC122S021 serves as the intermediary between the ATMEGA328P and the AC sensed signal. It samples the output produced by the AC voltage sensing network and transmits the data to the ATMEGA328P via SPI communication. The ATMEGA328P receives the sensed data by requesting channel 1 of the ADC122S021 and uses it to compute the RMS reading of the voltage. Figure X. AC Voltage Sensing Block Diagram . This section covers the hardware implementation for the AC sensing framework as illustrated above. To learn more about how the voltage RMS computation is performed and other key considerations for the software design, see the section AC Voltage Sensing Library Feature. ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-hardware"
  },"34": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing Network",
    "content": ". Figure X. AC Voltage Sensing Network . The design is comprised of two main stages: . | ZMPT101B Transformer . | Voltage step-down using 1:1 isolation transformer | Well known and documented for projects that interface with Arduino/ESP/RaspberryPi devices | . | Signal Conditioning and Amplification . | A cascaded pair of inverting op-amp configurations to amplify the low-voltage sensed signal | Tunable gain set by a potentiometer that aims to reduce potential saturation or improve resolution at AC sensing output | Active low-pass filter attenuates high frequecy noise and improve signal integrity | . | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-network",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#ac-voltage-sensing-network"
  },"35": {
    "doc": "AC Voltage Sensing",
    "title": "ZMPT101B Transformer",
    "content": "The first stage is based on the ZMPT101B current transformer. It is a 1:1, 1000V, 2mA rated transformer. For a more thorough documentation of the component, please review the ZMPT101B datasheet. The input to output voltage relation describing the transformer operation is stated in Figure II of the datasheet: . \\[U_{2} = \\frac{U_{1}}{R'} \\times R\\] where: . | $U_1$ is the input voltage | $U_2$ is the output voltage | $R‚Äô$ is the current limiting resistor | $R$ is the voltage sampling resistor | . In efforts to maintain consistency with the previous AC Voltage Circuit diagram, we will denote $U_1$, $U_2$, $R‚Äô$, $R$ as $V_{\\mathrm{AC_in}}$, $V_{\\mathrm{AC_samp}}$, $R_{lim}$, $R_{samp}$ respectively. Therefore, the newly denoted equation is . \\[V_{\\mathrm{AC_samp}} = \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#zmpt101b-transformer",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#zmpt101b-transformer"
  },"36": {
    "doc": "AC Voltage Sensing",
    "title": "üî¢ Calculating $R_{lim}$",
    "content": "To achieve higher levels of Signal-to-Noise Ratio (SNR), better ADC range, and noise immunity, a current limiting resistor $R_{lim}$ should be selected such that the magnitude is near the rated current but not exceeding. Choosing a current limiting resistor is based on the highest expected voltage that will be delivered to the input primary side of the transformer. Recalling that the maximum peak voltage for the power inverter is 48V, and considering that the transformer has a rated current of 2mA, a max current value of 1.5mA is chosen. This ensures that $V_{\\mathrm{AC_in}}$ is maximized in signal strength to improve resolution, but also provides buffer from operating the part at rated conditions. \\[R_{lim} = \\frac{V_{\\mathrm{AC_in}}}{I_{\\mathrm{AC_in}}}\\] \\[R_{lim} = \\frac{48V}{1.5mA} = 32k\\Omega\\] . | Choose $33k\\Omega$ based on standard resistor values | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_lim",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_lim"
  },"37": {
    "doc": "AC Voltage Sensing",
    "title": "üî¢ Calculating $R_{samp}$",
    "content": "The sampling resistance linearly influences the transformer AC voltage output as per the equation in Figure II. By rearragning the ZMPT101B expression, this renders the following equation usable for solving the sampling resistor in a passive configuration where no amplication is present. \\[V_{\\mathrm{AC_samp}} = \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] \\[R_{samp} = \\frac{V_{\\mathrm{AC_samp}}}{V_{\\mathrm{AC_in}}} \\times R_{lim}\\] However, this expression is not directly applicable since it makes use of an active configuration. Nonetheless, it can be adapted to suit the needs of the current design as detailed in the next section. ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_samp",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#-calculating-r_samp"
  },"38": {
    "doc": "AC Voltage Sensing",
    "title": "Signal Conditioning and Amplification",
    "content": "The second stage of the AC Voltage Sensing Network is a combination of two inverting amplication phases that serve the purpose of amplifying the low voltage signal produced across the sampling resistor. Each level provides an amplication factor of 10, yielding a net gain of 100. To develop a transfer function that accounts for this two op-amp amplification chain in the AC voltage sensing network, this gain stage can be modeled by a variable $G_{amp}$. This net gain is also equivalent to the product of the two intermediate gains $G_{1} \\times G_{2}$. The AC voltage from output to input then can be described as: . \\[V_{\\mathrm{ACsense}} = G_{amp} \\times \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp}\\] It is important to note that $V_{\\mathrm{ACsense}}$ refers to the desired AC magnitude that will be provided to the ADC122S021 after the two op amp chain whereas $V_{\\mathrm{ACsamp}}$ is the AC magnitude at the secondary of the transformer. The amplification phases are also designed to attenuate high frequency noise, as they are based on the active low pass filter topology. This is necessary because although the output of the transformer is being amplified in two segments, the noise present at the op-amp inputs can also amplified. It is beneficial to have this embedded into the design since $V_{\\mathrm{ACsense}}$ needs to be a clean waveform for accurate readings from the ADC122S021. The cutoff frequency of this 1st order low-pass filter can be calculated using the following formula: . \\[f_{c} = \\frac{1}{2\\pi \\times C_{lp} \\times R_{fb}}\\] Another key feature of the AC Voltage Sensing Network is the potentiometer, $R_{tune}$ as it also impacts the magnitude of $V_{\\mathrm{ACsense}}$. Since the potentiometer functions as a voltage divider, it can be modeled by introducing two resistors: $R_{tune1}$, the resistor in series with the signal path, and $R_{tune2}$, the resistor connected to ground. Therefore, the divider ratio is: . \\[G_{tune} = \\frac{R_{tune1}}{R_{tune1}+ R_{tune2}}\\] Since the divider ratio is effectively a gain constant between the first and second op amp chain, both of which are linearly combined, the specific placement of this term has no effect on the $V_{\\mathrm{ACsense}}$ computation. \\[V_{\\mathrm{ACsense}} = G_{amp} \\times \\frac{V_{\\mathrm{AC_in}}}{R_{lim}} \\times R_{samp} \\times G_{tune}\\] To obtain the final sampling resistor equation that, we can isolate for the sampling resistor: . \\[R_{samp} = \\frac{V_{\\mathrm{ACsense}}}{V_{\\mathrm{AC_in}} \\times G_{amp} \\times G_{tune}} \\times R_{lim}\\] The AC portion of the $V_{\\mathrm{ACsense}}$ signal must remain within the saturation limits of the LM358 op-amp due to resulting amplified signal being centered around a 2.5V DC offset, which is caused by the $R_{bias}$ resistors. Since the LM358 op amp saturates at about 1.5V from the supply voltage (i.e. 5V - 1.5V = 3.5V), then the maximum permissible swing is $V_{\\mathrm{ACsense}} = 1V_{pk}$. The worst case scenario for potential saturation occurs when the potentiometer provides no gain attenuation (i.e $G_{tune} = 1$), resulting in an amplification of $G_{amp}$ = 100 applied to $V_{\\mathrm{ACsamp}}$. Using this case to calculate the sampling resistor is performed for both ends of the inverter range. \\(V_{\\mathrm{AC_in}}\\) = 12V: . \\[R_{samp} = \\frac{1}{12 \\times 100 \\times 1} \\times 33k = 27.5\\Omega\\] \\(V_{\\mathrm{AC_in}}\\) = 48V: . \\[R_{samp} = \\frac{1}{48 \\times 100 \\times 1} \\times 33k = 6.87\\Omega\\] . | Choose $6.8\\Omega$ based on standard resistor values, as this accomodates for both 12V and 48V $V_{\\mathrm{AC_in}}$. The effective resolution of the sensed signal can then be improved by reducing $R_{tune}$, as this increases the output swing without exceeding the op-amp‚Äôs output swing range. | . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#signal-conditioning-and-amplification",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#signal-conditioning-and-amplification"
  },"39": {
    "doc": "AC Voltage Sensing",
    "title": "Simulation",
    "content": "The AC voltage sensing topology was simulated using LTSpice to verify operation. Since the LM358 is not an available in the component library, the OP07 amplifier was used as a suitable substitute. Figure X. AC Voltage Sensor Network Simulation Circuit . Figure X. AC Voltage Sensor Network Simulation Signals Plot . ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#simulation",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html#simulation"
  },"40": {
    "doc": "AC Voltage Sensing",
    "title": "AC Voltage Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/ac_volt_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/ac_volt_sensing_hw.html"
  },"41": {
    "doc": "Blink",
    "title": "Blink Library Feature",
    "content": ". ",
    "url": "/software/library/features/blink_feature.html#blink-library-feature",
    
    "relUrl": "/software/library/features/blink_feature.html#blink-library-feature"
  },"42": {
    "doc": "Blink",
    "title": "üìã Overview",
    "content": "The Blink feature abstracts low-level pin operations for LED control functionality within the Atinverter library. It includes methods for setting up GPIO pins as outputs, controlling individual LEDs, and cycling through multiple LEDs in a predefined sequence. ",
    "url": "/software/library/features/blink_feature.html#-overview",
    
    "relUrl": "/software/library/features/blink_feature.html#-overview"
  },"43": {
    "doc": "Blink",
    "title": "üìå Pin Assignments",
    "content": "This table shows the mapping of the LEDs and their corresponding ATMEGA328P pin assignments: . | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | Red LED 1 | LED1R_PIN | 2 | OUTPUT | . | Green LED 1 | LED1G_PIN | 3 | OUTPUT | . | Red LED 2 | LED2R_PIN | 4 | OUTPUT | . | Green LED 2 | LED2G_PIN | 7 | OUTPUT | . ",
    "url": "/software/library/features/blink_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/blink_feature.html#-pin-assignments"
  },"44": {
    "doc": "Blink",
    "title": "üìÇ Library Structure",
    "content": "Implementation in Atinverter.h: . // LED Pin Definitions static const int LED1R_PIN = 2; static const int LED1G_PIN = 3; static const int LED2R_PIN = 4; static const int LED2G_PIN = 7; // Methods void setUpLEDs(); void set1LED(int LED, int state); void cycleLEDs(int t_delay); . ",
    "url": "/software/library/features/blink_feature.html#-library-structure",
    
    "relUrl": "/software/library/features/blink_feature.html#-library-structure"
  },"45": {
    "doc": "Blink",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/blink_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/blink_feature.html#-method-descriptions"
  },"46": {
    "doc": "Blink",
    "title": "void setUpLEDs()",
    "content": "Purpose: Configures all LED pins as outputs. Pseudocode: . | Configure the state of all 4 LED pins as outputs for driving. | . Implementation in Atinverter.cpp: . void Atinverter::setUpLEDs() { pinMode(LED1R_PIN, OUTPUT); pinMode(LED1G_PIN, OUTPUT); pinMode(LED2R_PIN, OUTPUT); pinMode(LED2G_PIN, OUTPUT); } . ",
    "url": "/software/library/features/blink_feature.html#void-setupleds",
    
    "relUrl": "/software/library/features/blink_feature.html#void-setupleds"
  },"47": {
    "doc": "Blink",
    "title": "void set1LED(int LED, int state)",
    "content": "Purpose: Sets a user-selected LED pin as on or off. Pseudocode: . | Sets a user-selected LED pin as on (HIGH) or off (LOW). | . Implementation in Atinverter.cpp: . void Atinverter::set1LED(int LED, int state) { digitalWrite(LED, state); } . ",
    "url": "/software/library/features/blink_feature.html#void-set1ledint-led-int-state",
    
    "relUrl": "/software/library/features/blink_feature.html#void-set1ledint-led-int-state"
  },"48": {
    "doc": "Blink",
    "title": "void cycleLEDs(int t_delay)",
    "content": "Purpose: Sequentially cycles through four LEDs, turning each on and off with a delay. Pseudocode: . | Turns on each LED in order with a delay in between in milliseconds | Turns off each LED in reverse order with a delay in between in milliseconds | . Implementation in Atinverter.cpp: . void Atinverter::cycleLEDs(int t_delay) { digitalWrite(LED1G_PIN, HIGH); delay(t_delay); digitalWrite(LED1R_PIN, HIGH); delay(t_delay); digitalWrite(LED2G_PIN, HIGH); delay(t_delay); digitalWrite(LED2R_PIN, HIGH); delay(t_delay); digitalWrite(LED2R_PIN, LOW); delay(t_delay); digitalWrite(LED2G_PIN, LOW); delay(t_delay); digitalWrite(LED1R_PIN, LOW); delay(t_delay); digitalWrite(LED1G_PIN, LOW); delay(t_delay); } . ",
    "url": "/software/library/features/blink_feature.html#void-cycleledsint-t_delay",
    
    "relUrl": "/software/library/features/blink_feature.html#void-cycleledsint-t_delay"
  },"49": {
    "doc": "Blink",
    "title": "Blink",
    "content": " ",
    "url": "/software/library/features/blink_feature.html",
    
    "relUrl": "/software/library/features/blink_feature.html"
  },"50": {
    "doc": "Blink",
    "title": "Blink Module Program",
    "content": ". Purpose: This program demonstrates how to utilize the Atinverter library‚Äôs LED control features in a standalone application. This module is useful for confirming the operational state of the microcontroller, hardware connections, and library integration. ",
    "url": "/software/modules/blink_program.html#blink-module-program",
    
    "relUrl": "/software/modules/blink_program.html#blink-module-program"
  },"51": {
    "doc": "Blink",
    "title": "Blink.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance | Set up the period of time for delaying LED operations | Set the GPIO pins for LEDs as outputs | Turn on LED 1 | Turn on LED 2 | Wait for the defined period | Turn off LED 1 | Turn off LED 2 | Wait for the defined period | Cycle through LEDs with delay | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter; int PERIOD = 1000; void setup() { atinverter.setUpLEDs(); } void loop() { atinverter.set1LED(atinverter.LED1R_PIN, HIGH); atinverter.set1LED(atinverter.LED2G_PIN, HIGH); delay(PERIOD); atinverter.set1LED(atinverter.LED1R_PIN, LOW); atinverter.set1LED(atinverter.LED2G_PIN, LOW); delay(PERIOD); atinverter.cycleLEDs(PERIOD); } . ",
    "url": "/software/modules/blink_program.html#blinkino",
    
    "relUrl": "/software/modules/blink_program.html#blinkino"
  },"52": {
    "doc": "Blink",
    "title": "Blink",
    "content": " ",
    "url": "/software/modules/blink_program.html",
    
    "relUrl": "/software/modules/blink_program.html"
  },"53": {
    "doc": "Boost Converter",
    "title": "Boost Converter Hardware",
    "content": ". ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#boost-converter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#boost-converter-hardware"
  },"54": {
    "doc": "Boost Converter",
    "title": "Programming the Output Voltage",
    "content": "The output voltage of the boost converter is given by the following equation: . \\[R_{1} = \\left( \\frac{V_{OUT}}{V_{REF}} - 1 \\right) \\times R_{2}\\] Desire an output voltage of 12V, internal reference voltage is 795mV, choose R2, solve for R1. | $V_{OUT} = 12V$ | $V_{REF} = 795mV$ | $R_{2} = 71.5k\\Omega$ | . \\[R_{1} \\approx 1M\\Omega\\] . ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#programming-the-output-voltage",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#programming-the-output-voltage"
  },"55": {
    "doc": "Boost Converter",
    "title": "Inductor Selection",
    "content": "To determine the inductor current (input current draw): . \\[I_{L(DC)} = \\frac{V_{OUT} \\times I_{OUT}}{V_{IN} \\times \\eta}\\] . | $V_{OUT}$ = 12V | $V_{IN}$ = 5V | $\\eta$ = 0.8 (80% recommended by datasheet) | $I_{OUT}$ = ? | . Need to find the load current that will be drawn. This boost converter is only driving the two IR2302 gate drivers for our PWM Inverter H-bridge design so if we find the current consumed by these drivers, we will effectively find the output load to drive. The current consumption of a gate driver is based upon the static and dynamic current consumption. As per the IR2302 datasheet, the max possible Quiescent Vcc supply current $I_{QCC}$ = 1.6mA. Therefore, $I_{static}$ = 1.6mA. The dynamic current consumed by the device can be found by the following relation between the total gate charge of the MOSFET and the switching frequency: . $I_{dynamic}‚Äã = Q_{g} ‚Äã√ó f_{sw}$ . As per the IRFB4020PBF MOSFET datasheet, the maximum total gate charge is 29nC and the switching frequency of operation of the gate drivers is 31,372Hz. | $Q_{g} = 29nC$ | $f_{sw} = 31,372Hz$ | . Using these values, the dynamic current consumption of one MOSFET is: . $I_{dynamic}‚Äã = 0.91mA$ . Considering that the PWM inverter topology is based on 4 MOSFETs with only 2 operating at any given time simultaneously, this means the total dynamic current is $2 \\times I_{dynamic}‚Äã = 1.82mA$. Additionally, the quiescent current is dictated by two gate drivers so the total static current is $2 \\times I_{static}‚Äã = 3.2mA$. $I_{LOAD}‚Äã = I_{STATIC} ‚Äã+ I_{DYNAMIC}$ $I_{OUT}‚Äã = 5.02mA$ . Now that we have the total load current $I_{OUT}$ = 5.02mA, then we can solve for the inductor current using the following values: . | $V_{OUT} = 12V$ | $V_{IN} = 5V$ | $I_{OUT} = 5.02mA$ | $\\eta$ = 0.8 (80% recommended by datasheet) | . \\[I_{L(DC)} = 15.06mA\\] The inductor ripple current is calculated with Equation 3 for an asynchronous boost converter in continuous conduction mode (CCM). \\[\\Delta I_{L(\\text{P-P})} = \\frac{V_{IN} \\times (V_{OUT} + 0.8V - V_{IN})}{L \\times f_{SW} \\times (V_{OUT} + 0.8V)}\\] where: . | ŒîIL(P-P) is inductor ripple current | L is inductor value | f SW is switching frequency | VOUT is output voltage | VIN is input voltage | . ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html#inductor-selection",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html#inductor-selection"
  },"56": {
    "doc": "Boost Converter",
    "title": "Boost Converter",
    "content": ". ",
    "url": "/hardware/atinverter_v2/boost_conv_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/boost_conv_hw.html"
  },"57": {
    "doc": "Buck Converter",
    "title": "Buck Converter Hardware",
    "content": ". ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#buck-converter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#buck-converter-hardware"
  },"58": {
    "doc": "Buck Converter",
    "title": "Determining the DC/DC Converter Output Current Needed",
    "content": "Requirements . | Input Voltage: 12V-48V | Output Voltage: 5V | . ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-dcdc-converter-output-current-needed",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-dcdc-converter-output-current-needed"
  },"59": {
    "doc": "Buck Converter",
    "title": "Determining the Required Input Current and PCB Trace Thickness for Switching Converters",
    "content": "Chip parameters . | Chip of Interest: R-78HE-0.3 | DC-DC switching converter, not linear regulator | Input Voltage Range: 6.5V - 48V | Output Voltage: 5V | Output Current: Up to 300mA | Efficiency: Up to 83% | . Power Conversion Equations . (1) \\(P_{\\text{out}} = P_{\\text{in}} + P_{\\text{losses}}\\) (2) \\(Efficiency = \\frac{P_{\\text{out}}}{P_{\\text{in}}}\\) (3) \\(P_{\\text{in}}= V_{\\text{in}} \\times I_{\\text{in}}\\) (4) \\(P_{\\text{out}}= V_{\\text{out}} \\times I_{\\text{out}}\\) . | Plugging in equation (3) into (2) and isolating for \\(I_{\\text{in}}\\) results in: | . \\[I_{\\text{in}} = \\frac{P_{\\text{out}}}{V_{\\text{in}} \\times \\text{Efficiency}}\\] Finding the Maximum Input Current . | Known: \\(V_{\\text{out_max}} = 5V, I_{\\text{out_max}} = 300mA\\) \\(P_{\\text{out_max}} = 5 \\times 300m = 1.5W\\) . | Two cases are considered since the efficiency of the converter changes with the input voltage. \\(V_{\\text{in_max}} = 72\\), Efficiency = 72% \\(I_{\\text{in}} = \\frac{1.5W}{72 \\times \\text{0.72}} = 0.029A\\) \\(V_{\\text{in_min}} = 6.5\\), Efficiency = 83% \\(I_{\\text{in}} = \\frac{1.5W}{6.5 \\times \\text{83}} = 0.278A\\) . | Therefore, the maximum input current is 278mA. This is consistent with the inverse relationship between voltage and current in a DC-DC converter. Although the input current (278mA) is lower than the output current (300mA), the input voltage (6.5V) is higher than the output voltage (5V). This behavior is typical of switching converters, which take advantage of the complementary relationship between input and output voltage and current. | However, to be conservative, let‚Äôs say the chip consumes 300mA which is the same as the output current. This is a standard technique that is employed to approximate the current drawn from the converter especially for higher efficiencies. We could have utilized this approach, but now we know how to solve for the max input current for any converter. | Using Digikey PCB Trace Width Calculator . | The maximum input current is 0.3A and we are designing for a 1 oz copper thickness . | . | A required trace width of 0.148mm (5.83mils) is obtained | . ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-required-input-current-and-pcb-trace-thickness-for-switching-converters",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html#determining-the-required-input-current-and-pcb-trace-thickness-for-switching-converters"
  },"60": {
    "doc": "Buck Converter",
    "title": "Buck Converter",
    "content": " ",
    "url": "/hardware/atinverter_v2/buck_conv_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/buck_conv_hw.html"
  },"61": {
    "doc": "DC Current Sensing",
    "title": "DC Current Sensing Hardware",
    "content": ". The current at the DC input line is measured using a Hall-effect current sensor. Let‚Äôs briefly cover how this type of device operates. ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#dc-current-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#dc-current-sensing-hardware"
  },"62": {
    "doc": "DC Current Sensing",
    "title": "Hall-Effect Current Sensor Overview",
    "content": "To understand hall-effect current sensors, we need to consider two fundamental laws of electromagnetism: . | Lorentz Force Law | Ampere‚Äôs Law | . Rather than just explaining what the laws mean, let‚Äôs understand how they manifest themselves in the operation of the device. Consider a conductive element where a current flows. The yellow balls represent electrons that are evenly distributed when flowing through a conductor. The current flow is denoted as ‚ÄúI‚Äù. Figure X. DC Voltage Sensing Circuit . Ampere‚Äôs law tells us that a magnetic field is generated around the conductor in accordance with the right-hand rule and that magnetic field is proportional to the current that is flowing. Additionally, if an external magnetic field is applied near the conductor (strongest when perpendicular due to Lorentz force), the electrons will be deflected and accumulate in one area leaving the opposite side with a net positive charge. The charge separation between both ends can be measured ‚Äî known as the hall-voltage. Figure X. DC Voltage Sensing Circuit . ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#hall-effect-current-sensor-overview",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#hall-effect-current-sensor-overview"
  },"63": {
    "doc": "DC Current Sensing",
    "title": "TMCS1108",
    "content": "In this design, the TMCS1108 current sensor detects the magnetic field generated by the DC input current. It internally measures the hall-voltage and then amplifies it to produce an analog voltage output which is proportional to the sensed current. This analog voltage can be calculated using the TMCS1108 datasheet provided equation in page 12: . \\[V_{OUT} = S \\times I_{IN} + V_{OUT,0A}\\] where: . | $V_{OUT}$ is the analog output voltage. | S is the ideal sensitivity of the device. | $I_{IN}$ is the isolated input current. | $V_{OUT,0A}$ is the zero current output voltage for the device variant. | . As this design employs the TMCS1108A4BQDR device variant, this features a sensitivity is 400mV/A. This describes the relation between the output analog voltage and current input where the output changes 400mV for every 1A of detected current. Higher sensitivities are generally favorable, as they results in a greater voltage response per unit of current. The non-zero current output is due to the device bidirectionality of the sensor, where the output is centered at mid-supply as noted in page 3 of the TMCS1108 datasheet. \\[V_{OUT,0A} = 0.5 √ó V_{S}\\] where: . | $V_{OUT,0A}$ is the zero current output voltage for the device variant. | $V_{S}$ is the supply voltage to the chip. | . Since the chip is powered by a 5V supply, at no current input, the output analog voltage resides at 2.5V. For positive current, the output voltage increases above 2.5V and conversesly for negative current, the output decreases below 2.5V. The analog output voltage is then measured by the analog pin of our ATMEGA328P, where it is converted to a digital value between the range of 0-1023. After the MCU has an understanding of what the voltage signal is in the digital domain, the current for the DC input is computed using a restructured form of the previous equation. \\[I_{IN} = \\frac{V_{OUT} - V_{OUT,0A}}{S}\\] This conversion ultimately produces an accurate current reading based on the previously discussed hall-effect phenomenon and fulfills the goal of measuring the DC input current of the Atinverter V2 device. ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#tmcs1108",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html#tmcs1108"
  },"64": {
    "doc": "DC Current Sensing",
    "title": "DC Current Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/dc_curr_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/dc_curr_sensing_hw.html"
  },"65": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing Library Feature",
    "content": ". ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#dc-vi-sensing-library-feature",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#dc-vi-sensing-library-feature"
  },"66": {
    "doc": "DC V/I Sensing",
    "title": "üìã Overview",
    "content": "The DC Voltage and Current Sensing feature provides an interface for monitoring the input voltage and current of the PWM inverter. It utilizes the onboard ADC pins of the ATMEGA328P, along with TMCS1108A4BQDR Hall-effect current sensor. Voltage is measured through a resistive voltage divider, while current is measured using the analog output of the current sensor. These signals can be obtained through methods which use raw readouts of the ADC or for improved accuracy, through a running average sampling method. ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-overview",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-overview"
  },"67": {
    "doc": "DC V/I Sensing",
    "title": "üìå Pin Assignments",
    "content": "This table expresses the dedicated analog pins used for the design and their respective state. | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | DC Voltage Sensing | V_DC_PIN | A0 | INPUT | . | DC Current Sensing | I_DC_PIN | A1 | INPUT | . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-pin-assignments"
  },"68": {
    "doc": "DC V/I Sensing",
    "title": "üìÇ Library Structure",
    "content": "Implementation in Atinverter.h: . // TMCS1108 Current Sensor Parameters #define SENSOR_GAIN_MV_PER_A 400.0f // Sensitivity for A4 variant (400 mV per A) #define MV_TO_V 1000.0f // Scaling factor from mV to V #define VOUT_0A 2.5f // Zero current output voltage // ADC Parameters #define VREF 5.0f // Reference voltage for both ADCs #define ADC_ATMEGA328P_MAX_VALUE 1023.0f // For ATMEGA328P (internal ADC) // Moving Average Samples #define MA_SAMPLES 10 // DC Voltage and Current Pin Definitions static const int V_DC_PIN = A0; static const int I_DC_PIN = A1; // DC Voltage Sensing Resistor Values static const unsigned long Rvs1 = 120000; static const unsigned int Rsv2 = 9900; // Parameters for Vdc Moving Average static const int Vdc_num_readings = MA_SAMPLES; float Vdc_readings[MA_SAMPLES]; int Vdc_read_index = 0; float Vdc_total = 0; // Parameters for Idc Moving Average static const int Idc_num_readings = MA_SAMPLES; float Idc_readings[MA_SAMPLES]; int Idc_read_index = 0; float Idc_total = 0; // Method Declarations float getVdc(); float getIdc(); float getAvgDC(bool isVdc, float signalValue); . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-library-structure",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-library-structure"
  },"69": {
    "doc": "DC V/I Sensing",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#-method-descriptions"
  },"70": {
    "doc": "DC V/I Sensing",
    "title": "getVdc()",
    "content": "Purpose: Senses and returns the input DC voltage. Pseudocode: . | Read raw ADC value from ATMEGA328P analog pin connected to sensing voltage | Translate the digital ADC reading into its analog voltage equivalent . | \\[Sensed\\ Voltage = \\left( \\frac{Reference\\ Voltage \\times ADC\\ Reading}{2^{(ADC\\ Bits)} - 1} \\right)\\] | . | Convert the sensed voltage to the DC input voltage using rearranged voltage divider . | \\[Input\\ DC\\ Voltage = Sensed\\ Voltage \\times \\frac{(Top\\ Resistor + Bottom\\ Resistor)}{Top\\ Resistor}\\] | . | Return the calculated DC input voltage | . Implementation in Atinverter.cpp: . float Atinverter::getVdc() { int digital_val = analogRead(V_DC_PIN); float Vdc_sense = (VREF * digital_val) / (ADC_ATMEGA328P_MAX_VALUE); float Vdc = Vdc_sense * (Rvs1 + Rsv2) / Rsv2; return Vdc; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getvdc",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getvdc"
  },"71": {
    "doc": "DC V/I Sensing",
    "title": "getIdc()",
    "content": "Purpose: Senses and returns the input DC current. Pseudocode: . | Read raw ADC value from ATMEGA328P analog pin connected to TMCS1108 analog output | Translate the digital ADC reading into its analog voltage equivalent . | \\[Output\\ Voltage = \\left( \\frac{Reference\\ Voltage \\times ADC\\ Reading}{2^{(ADC\\ Bits)} - 1} \\right)\\] | . | Compute the input current using the transfer function from the TMCS1108 datasheet (equation 1 on page 12) . | \\[Input\\ DC\\ Current = \\left( \\frac{Output\\ Voltage - Zero\\ Current\\ Output\\ Voltage}{Sensitivity} \\right)\\] | . | Return the calculated DC input current | . Implementation in Atinverter.cpp: . float Atinverter::getIdc() { int digital_val = analogRead(I_DC_PIN); float Vout = (VREF * digital_val) / (ADC_ATMEGA328P_MAX_VALUE); float Idc = (Vout - VOUT_0A) / SENSOR_GAIN_MV_PER_A * MV_TO_V; return Idc; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getidc",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getidc"
  },"72": {
    "doc": "DC V/I Sensing",
    "title": "getAvgDC(bool isVdc, float signalValue)",
    "content": "Purpose: Computes and returns the moving average for the input DC voltage or current based on a pre-defined sample count. Pseudocode: . | Decide which sampling array will be utilized based on user input | Store the most recent value received in the buffer | Add the readings to the running total | Increment the sampling array index | Check if read index is above the buffer size . | If yes, reset buffer index | If no, continue | . | Compute the average signal using total over the number of readings | Substract the oldest reading to prepare for new readng | Return the averaged signal | . Implementation in Atinverter.cpp: . float Atinverter::getAvgDC(bool isVdc, float signalValue) { const int num_readings = isVdc ? Vdc_num_readings : Idc_num_readings; float* readings = isVdc ? Vdc_readings : Idc_readings; int&amp; read_index = isVdc ? Vdc_read_index : Idc_read_index; float&amp; total = isVdc ? Vdc_total : Idc_total; readings[read_index] = signalValue; total += readings[read_index]; read_index++; if (read_index &gt;= num_readings){ read_index = 0; } float avg_signal = total / num_readings; total -= readings[read_index]; return avg_signal; } . ",
    "url": "/software/library/features/dc_vi_sensing_feature.html#getavgdcbool-isvdc-float-signalvalue",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html#getavgdcbool-isvdc-float-signalvalue"
  },"73": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing",
    "content": ". ",
    "url": "/software/library/features/dc_vi_sensing_feature.html",
    
    "relUrl": "/software/library/features/dc_vi_sensing_feature.html"
  },"74": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing Module Programs",
    "content": ". Purpose: These two standalone programs (Vdc_Sensing.ino and Idc_Sensing.ino) showcase how to use the Atinverter library‚Äôs DC sensing features to monitor the input DC voltage and current of the PWM inverter. Both modules verify hardware connections, retrieve both raw and averaged sensor values, and employ the Timer 2 based delaying feature. ",
    "url": "/software/modules/dc_vi_sensing_program.html#dc-vi-sensing-module-programs",
    
    "relUrl": "/software/modules/dc_vi_sensing_program.html#dc-vi-sensing-module-programs"
  },"75": {
    "doc": "DC V/I Sensing",
    "title": "Vdc_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance set to 50Hz or 60Hz mode | Initialize the serial monitor for displaying DC voltage readings | Begin PWM operation at desired frequency | Initialize Timer 2 for time-based delay functionality | Read the raw input DC voltage | Print raw input DC voltage to the serial monitor | Pass the most recent reading to the getAvgDC method to calculate the running average | Print averaged input DC voltage to the serial monitor | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter (60); void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Input DC Voltage Sensing.\")); atinverter.startPWM(false); atinverter.initTimer2Delay(); } void loop() { float raw_Vdc = atinverter.getVdc(); Serial.print(F(\"Raw Vdc : \")); Serial.print(raw_Vdc); Serial.println(F(\"V\")); float avg_Vdc = atinverter.getAvgDC(true, raw_Vdc); Serial.print(F(\"Avg Vdc : \")); Serial.print(avg_Vdc); Serial.println(F(\"V\")); Serial.println(); atinverter.delay2(500); } . ",
    "url": "/software/modules/dc_vi_sensing_program.html#vdc_sensingino",
    
    "relUrl": "/software/modules/dc_vi_sensing_program.html#vdc_sensingino"
  },"76": {
    "doc": "DC V/I Sensing",
    "title": "Idc_Sensing.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create a new Atinverter instance set to 50Hz or 60Hz mode | Initialize the serial monitor for displaying DC current readings | Begin PWM operation at desired frequency | Initialize Timer 2 for time-based delay functionality | Read the raw input DC current | Print raw input DC current to the serial monitor | Pass the most recent reading to the getAvgDC method to calculate the running average | Print averaged input DC current to the serial monitor | Wait a designated delay before printing the next reading | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter (60); void setup() { Serial.begin(9600); Serial.println(F(\"Initialize Input DC Current Sensing.\")); atinverter.startPWM(false); atinverter.initTimer2Delay(); } void loop() { float raw_Idc = atinverter.getIdc(); Serial.print(F(\"Raw Idc : \")); Serial.print(raw_Idc); Serial.println(F(\"A\")); float avg_Idc = atinverter.getAvgDC(false, raw_Idc); Serial.print(F(\"Avg Idc : \")); Serial.print(avg_Idc); Serial.println(F(\"A\")); Serial.println(); atinverter.delay2(500); } . ",
    "url": "/software/modules/dc_vi_sensing_program.html#idc_sensingino",
    
    "relUrl": "/software/modules/dc_vi_sensing_program.html#idc_sensingino"
  },"77": {
    "doc": "DC V/I Sensing",
    "title": "DC V/I Sensing",
    "content": " ",
    "url": "/software/modules/dc_vi_sensing_program.html",
    
    "relUrl": "/software/modules/dc_vi_sensing_program.html"
  },"78": {
    "doc": "DC Voltage Sensing",
    "title": "DC Voltage Sensing Hardware",
    "content": ". Voltage sensing of the DC input ($V_{DC}$) is achieved through a simple resistive divider. The resistive divider is made up of a limiting current resistor ($R_{limit}$) paired with a sensing resistor ($R_{sense}$). The voltage across the sensing resistance is measured by an ATMEGA328P analog pin which senses a voltage in the range of 0-5V ($V_{sense}$). It should be noted that the ATMEGA328P I/O pins cannot exceed 5V, as doing so may result in permanent damage to the MCU. Figure X. DC Voltage Sensing Circuit . Resistors values are chosen based on this condition as well as drawing an insignificant amount of power from the DC input, since the current in this path is to be delivered primarily to the output load. The resistor values of $R_{limit} = 120k\\Omega$ and $R_{sense} = 10k\\Omega$ were chosen based on the standard voltage divider equation: . \\[V_{sense} = V_{DC} \\times \\left( \\frac{R_{sense}}{R_{sense}\\times R_{limit}} \\right)\\] Given that the nominal DC input range is 12V to 48V, this translates to a sensed voltage as low as 0.92V and a high as 3.69V. It is evident that the full scale range of the analog pin is not used (0-5V), but this is intentional to account for potential overvoltage driving at the DC pin. Nonetheless, the 10 bit analog to digital converter (ADC) of the ATMEGA328P works as necessary in detecting the DC voltage based on the design parameters selected. ",
    "url": "/hardware/atinverter_v2/dc_volt_sensing_hw.html#dc-voltage-sensing-hardware",
    
    "relUrl": "/hardware/atinverter_v2/dc_volt_sensing_hw.html#dc-voltage-sensing-hardware"
  },"79": {
    "doc": "DC Voltage Sensing",
    "title": "DC Voltage Sensing",
    "content": ". ",
    "url": "/hardware/atinverter_v2/dc_volt_sensing_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/dc_volt_sensing_hw.html"
  },"80": {
    "doc": "Hardware",
    "title": "Hardware",
    "content": ". Atinverter V1 Atinverter V2 . ",
    "url": "/hardware/hardware.html",
    
    "relUrl": "/hardware/hardware.html"
  },"81": {
    "doc": "Home",
    "title": "Atinverter Documentation",
    "content": "Explore the documentation to learn more about this open source power converter! . Vision Hardware Software . ",
    "url": "/#atinverter-documentation",
    
    "relUrl": "/#atinverter-documentation"
  },"82": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"83": {
    "doc": "Inter-Board Communication",
    "title": "I2C Inter-Board Communication Hardware",
    "content": ". | Will be documented once I2C bus is verified | . ",
    "url": "/hardware/atinverter_v2/inter_board_comms.html#i2c-inter-board-communication-hardware",
    
    "relUrl": "/hardware/atinverter_v2/inter_board_comms.html#i2c-inter-board-communication-hardware"
  },"84": {
    "doc": "Inter-Board Communication",
    "title": "Inter-Board Communication",
    "content": " ",
    "url": "/hardware/atinverter_v2/inter_board_comms.html",
    
    "relUrl": "/hardware/atinverter_v2/inter_board_comms.html"
  },"85": {
    "doc": "LED Blinking",
    "title": "LED Blinking Hardware",
    "content": ". The LED circuit is effectively four LEDs that are independently controlled using four different GPIO pins of the ATMEGA328P. Figure X. LED Blinking Circuit . These LEDs are cycled on and off using a blink program providing a trivial aesthetic effect, but its primary purpose is a functional verfication of ATMEGA328P. Using a visual indictator allows us to determine if the MCU is bootloaded, which is a necessary step when working with a brand-new chip. ",
    "url": "/hardware/atinverter_v2/led_blinking_hw.html#led-blinking-hardware",
    
    "relUrl": "/hardware/atinverter_v2/led_blinking_hw.html#led-blinking-hardware"
  },"86": {
    "doc": "LED Blinking",
    "title": "LED Blinking",
    "content": ". ",
    "url": "/hardware/atinverter_v2/led_blinking_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/led_blinking_hw.html"
  },"87": {
    "doc": "Library",
    "title": "Atinverter V2 Library",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 library! . ",
    "url": "/software/library/library.html#atinverter-v2-library",
    
    "relUrl": "/software/library/library.html#atinverter-v2-library"
  },"88": {
    "doc": "Library",
    "title": "Library",
    "content": " ",
    "url": "/software/library/library.html",
    
    "relUrl": "/software/library/library.html"
  },"89": {
    "doc": "Features",
    "title": "Atinverter V2 Library Features",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 library features! . ",
    "url": "/software/library/features/library_features.html#atinverter-v2-library-features",
    
    "relUrl": "/software/library/features/library_features.html#atinverter-v2-library-features"
  },"90": {
    "doc": "Features",
    "title": "Features",
    "content": " ",
    "url": "/software/library/features/library_features.html",
    
    "relUrl": "/software/library/features/library_features.html"
  },"91": {
    "doc": "Reference",
    "title": "Atinverter V2 Library Reference",
    "content": ". The Atinverter library is comprised of two files: Atinverter.h and Atinverter.cpp. The header file serves as the blueprint containing the Atinverter class definition, along with its method declarations and member variables. The implementation for the Atinverter class and initilization of member variables are defined in Atinverter.cpp. At a high level, the Atinverter is essentially just two files as illustrated below: . Figure X. Atinverter Library High Level . Upon further inspection of the Atinverter Library, we can observe that it is organized into five main sections based on functionality. The nodes for the five features of the library are interactive‚Äîclick to explore specific software functionality and learn more about its design. Additionally, the code is thoroughly documented within the program files, so these sections will focus primarily on providing an overview of the design and any algorithms that were implemented. Figure X. Atinverter Library Expanded View . ",
    "url": "/software/library/library_reference.html#atinverter-v2-library-reference",
    
    "relUrl": "/software/library/library_reference.html#atinverter-v2-library-reference"
  },"92": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/software/library/library_reference.html",
    
    "relUrl": "/software/library/library_reference.html"
  },"93": {
    "doc": "Set Up",
    "title": "Atinverter Library Set Up",
    "content": "A guide to help your Arduino IDE recognize and use the Atinverter user-defined library . You might be thinking: . üí≠ ‚ÄúOkay, I downloaded the software files from the GitHub repository ‚Äî now what? Can I just open some random file like blink.ino and run the code?‚Äù . You‚Äôre almost there! There is just one important step that needs to happen first; We need ensure that the Arduino IDE knows where to find the Atinverter library files (Atinverter.cpp, Atinverter.h), or else you‚Äôll run into the notorious: . fatal error: Atinverter.h: No such file or directory . ",
    "url": "/software/library/library_setup.html#atinverter-library-set-up",
    
    "relUrl": "/software/library/library_setup.html#atinverter-library-set-up"
  },"94": {
    "doc": "Set Up",
    "title": "üìÅ How Arduino Handles Libraries",
    "content": "The Arduino IDE looks for user-defined libraries in a specific directory on your computer. Simply placing .cpp or .h files in the same directory as the .ino files you wish to run isn‚Äôt enough. Here‚Äôs where those locations are: . üîç If you‚Äôre on Windows, it‚Äôll be in: . C:\\Users&lt;YourUsername&gt;\\Documents\\Arduino\\libraries\\ . üîç If you‚Äôre on macOS or Linux, it‚Äôll be in: . ~/Documents/Arduino/libraries/ . ",
    "url": "/software/library/library_setup.html#-how-arduino-handles-libraries",
    
    "relUrl": "/software/library/library_setup.html#-how-arduino-handles-libraries"
  },"95": {
    "doc": "Set Up",
    "title": "‚úÖ What To Do",
    "content": ". | Navigate to the Atinverter library folder in the repository. It contains the source files Atinverter.cpp, Atinverter.h, and the metadata file library.properties. It is located in: . \\AtInverter\\software\\Library . | Copy the Atinverter folder to your Arduino libraries folder as described in How Arduino Handles Libraries . | . üì∏ You should expect to see something like this in your Arduino libraries folder: . ",
    "url": "/software/library/library_setup.html#-what-to-do",
    
    "relUrl": "/software/library/library_setup.html#-what-to-do"
  },"96": {
    "doc": "Set Up",
    "title": "üöÄ You‚Äôre Good to Go",
    "content": "Once the Atinverter library is in the right place, you can use it any sketch with: . #include \"Atinverter.h\" . ",
    "url": "/software/library/library_setup.html#-youre-good-to-go",
    
    "relUrl": "/software/library/library_setup.html#-youre-good-to-go"
  },"97": {
    "doc": "Set Up",
    "title": "Set Up",
    "content": " ",
    "url": "/software/library/library_setup.html",
    
    "relUrl": "/software/library/library_setup.html"
  },"98": {
    "doc": "UML Diagram",
    "title": "Atinverter UML Diagram",
    "content": ". Needs to be updated to reflect new changes!! . classDiagram class Atinverter { + LED1R_PIN : int + LED1G_PIN : int + LED2R_PIN : int + LED2G_PIN : int - VI_AC_CS_PIN : int - VI_AC_MOSI_PIN : int - VI_AC_MISO_PIN : int - VI_AC_SCLK_PIN : int - V_DC_PIN : int - I_DC_PIN : int - PWM_A_PIN : int - PWM_B_PIN : int - I2C_SDA_PIN : int - I2C_SCL_PIN : int - PRORESET_PIN : int - GATESD_PIN : int - Rvs1 : unsigned long - Rsv2 : unsigned int - num_readings : int - readings : float[num_readings] - read_index : int - total : float - is50Hz : bool - sin_i : int - pwm_i : int - OK : int - sin50HzPWM : int[312] - sin60HzPWM : int[261] + Atinverter() + setUpPinMode() : void + readVdc() : float + readAvgVdc(Vdc : float) : float + readIdc() : float + readAvgIdc(Idc : float) : float + setUpSPI() : void + readADC() : int + set1LED(led : int, state : int) : void + set2LED(t_delay : int) : void + enablePWM() : void + disablePWM() : void + startPWM(is50HzMode : bool) : void + pwmISR() : void } . ",
    "url": "/software/library/library_uml.html#atinverter-uml-diagram",
    
    "relUrl": "/software/library/library_uml.html#atinverter-uml-diagram"
  },"99": {
    "doc": "UML Diagram",
    "title": "UML Diagram",
    "content": " ",
    "url": "/software/library/library_uml.html",
    
    "relUrl": "/software/library/library_uml.html"
  },"100": {
    "doc": "Main",
    "title": "Main Module Program",
    "content": ". | To be documented in the future | . ",
    "url": "/software/modules/main_program.html#main-module-program",
    
    "relUrl": "/software/modules/main_program.html#main-module-program"
  },"101": {
    "doc": "Main",
    "title": "Main",
    "content": " ",
    "url": "/software/modules/main_program.html",
    
    "relUrl": "/software/modules/main_program.html"
  },"102": {
    "doc": "Modules",
    "title": "Atinverter V2 Library",
    "content": ". Click on any of the following sections to the learn more about the Atinverter V2 program modules! . ",
    "url": "/software/modules/modules.html#atinverter-v2-library",
    
    "relUrl": "/software/modules/modules.html#atinverter-v2-library"
  },"103": {
    "doc": "Modules",
    "title": "Modules",
    "content": " ",
    "url": "/software/modules/modules.html",
    
    "relUrl": "/software/modules/modules.html"
  },"104": {
    "doc": "Power Inverter",
    "title": "Power Inverter Hardware",
    "content": ". The Atinverter V2 power inverter is based on a single phase PWM inverter topology that is software-configurable for either 50Hz or 60Hz output. Pulse-width modulation (PWM) signals are generated by the ATMEGA328P microcontroller unit (MCU) using its hardware PWM pins. This signal is conditioned by a pair of gate drivers before being delivered to the H-bridge topology which converts the control signals into power signals. Once this power signal is filtered to attenuate high frequency content using a dual-LC filter, it is delivered to the load. Figure X. Power Inverter Signal Chain . While the majority of the inverter architecture was carried over from the original Atinverter V1 design, two key hardware modifications were introduced in this iteration: . | Reduced bootstrap capacitor size: Decreased from 4.7‚ÄØ¬µF to 1‚ÄØ¬µF to limit inrush current and enhance switching efficiency. | Higher gate drive voltage: The MOSFETs are now driven at a gate-to-source voltage of 12V instead of 5V, significantly improving conduction efficiency and reducing switching losses. | . The following sections provide a more detailed breakdown of each stage within the inverter signal chain. ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#power-inverter-hardware",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#power-inverter-hardware"
  },"105": {
    "doc": "Power Inverter",
    "title": "„Ä∞Ô∏è PWM Generation",
    "content": "The power inverter operation is catalyzed by the PWM generation from the ATMEGA328P. This MCU generates pulse-width modulated (PWM) square waves that, when combined with an appropriate switching circuit and filtering stage, can approximate the output of a pure sine wave power inverter. While there are other simpler approaches that can be employed to achieve inversion, such as square wave or modified square wave inverters, this one achieves higher levels of waveform fidelity. In other words, this modulation technique allows our output waveform to behave and appear more like a real sine wave. Source: Different Types of AC signals Produced by Inverters . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#%EF%B8%8F-pwm-generation",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#Ô∏è-pwm-generation"
  },"106": {
    "doc": "Power Inverter",
    "title": "üß† Gate Drivers",
    "content": "The next stage in the power signal chain is the gate driver circuit. It performs two main tasks: . | Enabling high-side transistor drive capability in H-bridge through a bootstrap circuitry by level shifting the low-voltage PWM signals from the ATMEGA328P to higher voltages | Enhance current delivery to the power transistors by sourcing gate drive current from an external supply, enabling rapid charging and discharging of gate capacitance for efficient switching. | . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-gate-drivers",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-gate-drivers"
  },"107": {
    "doc": "Power Inverter",
    "title": "üîÅ H-Bridge Topology",
    "content": "Being composed of 4 power transistors that complimentarily switch at a specific frequency, the H-bridge topology is a conventional design that is widely implemented in many pure sine wave inverters. This design enables the connected load to experience a positive and negative voltage swing solely based on switching states, effectively eliminating the need for a negative supply rail. This dual-polarity effect is what allows for the production of a full AC swing across the load and is achieved by PWM control signals as well as only one DC supply. ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-h-bridge-topology",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-h-bridge-topology"
  },"108": {
    "doc": "Power Inverter",
    "title": "üîâ LC Filter",
    "content": "Prior to the delivering the power to the load, a low pass filter stage is employed to: . | Remove high frequency content, especially the switching frequency of the PWM signals. | Preserve the fundamental frequency of interest. In our case, our PWM-based inverter is designed for 50 or 60Hz. | . ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html#-lc-filter",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html#-lc-filter"
  },"109": {
    "doc": "Power Inverter",
    "title": "Power Inverter",
    "content": " ",
    "url": "/hardware/atinverter_v2/power_inverter_hw.html",
    
    "relUrl": "/hardware/atinverter_v2/power_inverter_hw.html"
  },"110": {
    "doc": "Atinverter V1/2 Power Rating",
    "title": "Hardware",
    "content": ". MOSFETs (IRFB4020PBF): . | Continuous Drain Current (ID): 18 A at 25¬∞C | Drain-to-Source Voltage (VDSS): 200 V | Maximum Power Dissipation (PD): 100 W at 25¬∞C | . Inductors (AIRD-02-221K): . | Inductance: 220 ¬µH ‚Äã | Current Rating: . | Continuous: 2.8 A | Saturation: 7 A | . | . Capacitors (1189-4160-1-ND): . | Rated Voltage 250V | Ripple Current @ Low Frequency: 188 mA @ 120 Hz | Ripple Current @ High Frequency: 470 mA @ 100 kHz | . Theoretical max: . | Pmax = Vmax * Imax = 200V * 2.8A = 560W | . BUUUTTTT ‚Äî that‚Äôs theoretical! Needn to consider: . | Need to consider proper heatsinking for the MOSFETs (18 A is at 25¬∞C, derates with temp) | Ripple current through cap &lt; 470mA | Safe design margin: do not run at 100% ratings | Consider switching trajectory | . Reasonably speaking somwhere up to 450W . ",
    "url": "/hardware/power_rating.html#hardware",
    
    "relUrl": "/hardware/power_rating.html#hardware"
  },"111": {
    "doc": "Atinverter V1/2 Power Rating",
    "title": "Atinverter V1/2 Power Rating",
    "content": " ",
    "url": "/hardware/power_rating.html",
    
    "relUrl": "/hardware/power_rating.html"
  },"112": {
    "doc": "PWM Inversion",
    "title": "50Hz/60Hz PWM Inversion Library Feature",
    "content": ". ",
    "url": "/software/library/features/pwm_inversion_feature.html#50hz60hz-pwm-inversion-library-feature",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#50hz60hz-pwm-inversion-library-feature"
  },"113": {
    "doc": "PWM Inversion",
    "title": "üìã Overview",
    "content": "This section aims to document the functionality of the Atinverter library‚Äôs PWM generation feature, used to synthesize a sinusoidal waveform using a timer-driven software control scheme. The PWM waveform is composed of high-frequency switching pulses generated by Timer1 interrupts, which step through a precomputed sine lookup table at a rate of 31,372‚ÄØkHz. Simultaneously, Timer0 is configured to Phase Correct PWM mode and alternates the output between two hardware PWM pins to approximate a 50‚ÄØHz or 60‚ÄØHz AC signal. The software manages duty cycle updates and pin toggling using ISR logic, ultimately enabling fully software-defined sinusoidal PWM output from the ATMEGA328P. ",
    "url": "/software/library/features/pwm_inversion_feature.html#-overview",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-overview"
  },"114": {
    "doc": "PWM Inversion",
    "title": "üìå Pin Assignments",
    "content": "This table demonstrates PWM pins and their corresponding ATMEGA328P pin states: . | Pin Description | Pin Name (Code) | Pin Number | Pin State | . | PWM A Side | PWM_A_PIN | 5 | OUTPUT | . | PWM B Side | PWM_B_PIN | 6 | OUTPUT | . | Gate Shutdown | GATESD_PIN | 8 | INPUT | . | Protection Reset | PRORESET_PIN | 9 | OUTPUT | . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-pin-assignments",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-pin-assignments"
  },"115": {
    "doc": "PWM Inversion",
    "title": "üìÇ Library Structure",
    "content": "Implementation in Atinverter.h: . // PWM Pin Definitions= const int PWM_A_PIN = 5; const int PWM_B_PIN = 6; const int GATESD_PIN = 8; const int PRORESET_PIN = 9; // Parameters for PWM static bool is50Hz; static int sin_i; static int pwm_i; static int OK; static const int sin50HzPWM[312]; static const int sin60HzPWM[261]; // Methods void startPWM(bool is50HzMode); static void pwmISR(); void enablePWM(); void disablePWM(); . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-library-structure",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-library-structure"
  },"116": {
    "doc": "PWM Inversion",
    "title": "üßÆ 50Hz and 60Hz Sinusoid Lookup Table",
    "content": "// Define the sinusoidal 50Hz sample array (312 points) const int Atinverter::sin50HzPWM[] = { 1,2,5,7,10,12,15,17,19,22,24,27,30,32,34,37,39,42,44,47,49,52,54,57,59,61,64,66, 69,71,73,76,78,80,83,85,88,90,92,94,97,99,101,103,106,108,110,113,115,117,119,121, 124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164, 166,168,169,171,173,175,177,178,180,182,184,185,187,188,190,192,193,195,196,198,199, 201,202,204,205,207,208,209,211,212,213,215,216,217,219,220,221,222,223,224,225,226, 227,228,229,230,231,232,233,234,235,236,237,237,238,239,240,240,241,242,242,243,243, 244,244,245,245,246,246,247,247,247,248,248,248,248,249,249,249,249,249,255,255,255, 255,249,249,249,249,249,248,248,248,248,247,247,247,246,246,245,245,244,244,243,243, 242,242,241,240,240,239,238,237,237,236,235,234,233,232,231,230,229,228,227,226,225, 224,223,222,221,220,219,217,216,215,213,212,211,209,208,207,205,204,202,201,199,198, 196,195,193,192,190,188,187,185,184,182,180,178,177,175,173,171,169,168,166,164,162, 160,158,156,154,152,150,148,146,144,142,140,138,136,134,132,130,128,126,124,121,119, 117,115,113,110,108,106,103,101,99,97,94,92,90,88,85,83,80,78,76,73,71,69,66,64,61, 59,57,54,52,49,47,44,42,39,37,34,32,30,27,24,22,19,17,15,12,10,7,5,2,1}; // Define the sinusoidal 60Hz sample array (261 points) const int Atinverter::sin60HzPWM[] = { 1,3,6,9,12,15,18,21,24,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,73,76,79, 82,85,88,91,93,96,99,102,104,107,110,112,115,118,120,123,126,128,131,133,136,138, 141,143,146,148,151,153,155,158,160,162,165,167,169,171,173,176,178,180,182,184, 186,188,190,192,194,196,197,199,201,203,205,206,208,210,211,213,214,216,217,219, 220,222,223,224,226,227,228,229,230,232,233,234,235,236,237,238,239,239,240,241, 242,243,243,244,244,245,246,246,247,247,247,248,248,248,249,249,249,249,249,249, 249,249,249,249,249,249,248,248,248,247,247,247,246,246,245,244,244,243,243,242, 241,240,239,239,238,237,236,235,234,233,232,230,229,228,227,226,224,223,222,220, 219,217,216,214,213,211,210,208,206,205,203,201,199,197,196,194,192,190,188,186, 184,182,180,178,176,173,171,169,167,165,162,160,158,155,153,151,148,146,143,141, 138,136,133,131,128,126,123,120,118,115,112,110,107,104,102,99,96,93,91,88,85,82, 79,76,73,71,68,65,62,59,56,53,50,47,44,41,38,35,32,29,26,24,21,18,15,12,9,6,3,1}; . ",
    "url": "/software/library/features/pwm_inversion_feature.html#-50hz-and-60hz-sinusoid-lookup-table",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-50hz-and-60hz-sinusoid-lookup-table"
  },"117": {
    "doc": "PWM Inversion",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/pwm_inversion_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#-method-descriptions"
  },"118": {
    "doc": "PWM Inversion",
    "title": "void startPWM(bool is50HzMode)",
    "content": "Purpose: Begins PWM and initializes all required timers and registers for 50Hz or 60Hz PWM generation. Pseudocode: . | Disable global interrupts | Set 50Hz or 60Hz mode based on user input flag | Configure PWM pins as outputs | Set reset logic pin (PRORESET) as output and drive LOW to ensure gate driver is on | Set gate shutdown pin (GATESD) as input to allow logic protection circuitry to control gate drivers | Reset control register A, B, and the counter | Set up Timer0 for Phase Correct PWM (8-bit) with no prescaler | Set up Timer1 for CTC mode to trigger the waveform stepping ISR | Set compare match value depending on input flag | Enable Timer1 Compare A interrupt | Re-enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::startPWM(bool is50HzMode) { cli(); is50Hz = is50HzMode; pinMode(PWM_A_PIN, OUTPUT); pinMode(PWM_B_PIN, OUTPUT); pinMode(PRORESET_PIN, OUTPUT); digitalWrite(PRORESET_PIN, LOW); pinMode(GATESD_PIN, INPUT); TCCR0A = 0; TCCR0B = 0; TCNT0 = 0; TCCR0A = 0b10100001; TCCR0B = 0b00000001; TCCR1A = is50Hz ? 0b1000010 : 0; TCCR1B = 0; TCNT1 = 0; OCR1A = is50Hz ? 624 : 509; TCCR1B = 0b00001001; TIMSK1 |= (1 &lt;&lt; OCIE1A); sei(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-startpwmbool-is50hzmode",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-startpwmbool-is50hzmode"
  },"119": {
    "doc": "PWM Inversion",
    "title": "static void pwmISR()",
    "content": "Purpose: . Pseudocode: . | Select sinusoid lookup table based on frequency mode flag is50Hz | Determine the max index for lookup table based on the frequency mode flag | If the end of the lookup table has been reached and the digital pin flag OK is set LOW (indicates that digital pin 6 is currently active except for first pwmISR() iteration): . | Reset lookup table index and toggle the digital pin flag to activate pin 5 and deactivate pin 6 in the same cycle | . | If the end of the lookup table has been reached and the digital pin flag OK is set HIGH (indicates that digital pin 5 is currently active except for first pwmISR() iteration): . | Reset lookup table index and toggle to digital pin flag to activate pin 6 and deactivate pin 5 in the same cycle | . | Load PWM pulse value from lookup table | Increment the lookup table index sin_i to move to the next sample | If OK flag is off: . | Set digital pin 5 (OCR0B) off | Set digital pin 6 (OCR0A) to output current PWM pulse | . | If OK flag is on: . | Set digital pin 6 (OCR0A) off | Set digital pin 5 (OCR0B) to output current PWM pulse | . | . Implementation in Atinverter.cpp: . void Atinverter::pwmISR() { const int* sinPWM = is50Hz ? sin50HzPWM : sin60HzPWM; int maxIndex = is50Hz ? 313 : 260; if (sin_i &gt; maxIndex &amp;&amp; OK == 0) { sin_i = 0; OK = 1; } else if (sin_i &gt; maxIndex &amp;&amp; OK == 1) { sin_i = 0; OK = 0; } pwm_i = sinPWM[sin_i]; sin_i++; if (OK == 0) { OCR0B = 0; OCR0A = pwm_i; } else { OCR0A = 0; OCR0B = pwm_i; } } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#static-void-pwmisr",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#static-void-pwmisr"
  },"120": {
    "doc": "PWM Inversion",
    "title": "void enablePWM()",
    "content": "Purpose: Enables the Timer1 interrupts so that PWM generation resumes. Pseudocode: . | Disable global interrupts | Enable the Timer1 Compare Match A interrupt (OCIE1A) | Re-enable global interrupts | . Implementation in Atinverter.cpp: . cli(); TIMSK1 |= (1 &lt;&lt; OCIE1A); sei(); . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-enablepwm",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-enablepwm"
  },"121": {
    "doc": "PWM Inversion",
    "title": "void disablePWM()",
    "content": "Purpose: Disables the Timer1 interrupts to stop PWM generation without affecting other global interrupts. Pseudocode: . | Disable global interrupts | Disable the Timer1 Compare Match A interrupt interrupts (OCIE1A) | Re-enable global interrupts | . Implementation in Atinverter.cpp: . cli(); // Avoid ISR firing during mask change TIMSK1 &amp;= ~(1 &lt;&lt; OCIE1A); // Disable only the Timer1 Compare A interrupt sei(); // Resume normal operation . ",
    "url": "/software/library/features/pwm_inversion_feature.html#void-disablepwm",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#void-disablepwm"
  },"122": {
    "doc": "PWM Inversion",
    "title": "‚èπÔ∏è ISR Description",
    "content": " ",
    "url": "/software/library/features/pwm_inversion_feature.html#%EF%B8%8F-isr-description",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#Ô∏è-isr-description"
  },"123": {
    "doc": "PWM Inversion",
    "title": "ISR(TIMER1_COMPA_vect)",
    "content": "Purpose: This interrupt service routine (ISR) is triggered at each Timer1 compare match and calls the pwmISR() method to update the output PWM waveform. *Note: A separate static method Atinverter::pwmISR() is used instead of embedding the PWM logic directly inside the ISR(TIMER1_COMPA_vect) since ISRs cannot access instances of a class as they are not tied directly to an object. The PWM parameters is50Hz, sin_i, pwm_i, OK, sin50HzPWM, and sin60HzPWM are based on an instance of the Atinverter class. Pseudocode: . | Call Atinverter::pwmISR() to step through the sinusoidal array samples | . Implementation in Atinverter.cpp: . ISR(TIMER1_COMPA_vect) { Atinverter::pwmISR(); } . ",
    "url": "/software/library/features/pwm_inversion_feature.html#isrtimer1_compa_vect",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html#isrtimer1_compa_vect"
  },"124": {
    "doc": "PWM Inversion",
    "title": "PWM Inversion",
    "content": ". ",
    "url": "/software/library/features/pwm_inversion_feature.html",
    
    "relUrl": "/software/library/features/pwm_inversion_feature.html"
  },"125": {
    "doc": "PWM Inversion",
    "title": "50Hz/60Hz PWM Inversion Module Programs",
    "content": ". Purpose: These two standalone programs (50Hz_PWM_Inverter.ino and 60Hz_PWM_Inverter.ino) exhibits how to utilize the Atinverter library‚Äôs PWM generation functionality for the PWM inverter. Each file initializes the PWM for at a switching frequency of 31,372kHz and fundamental frequency of 50Hz or 60Hz, which are required for AC waveform generation. ",
    "url": "/software/modules/pwm_inversion_program.html#50hz60hz-pwm-inversion-module-programs",
    
    "relUrl": "/software/modules/pwm_inversion_program.html#50hz60hz-pwm-inversion-module-programs"
  },"126": {
    "doc": "PWM Inversion",
    "title": "50Hz_PWM_Inverter.ino",
    "content": "Pseudocode: . | Include the Atinverter library | Create an Atinverter instance set to 50Hz mode | Start PWM generation in 50Hz mode | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter(50); void setup(){ atinverter.startPWM(true); } void loop(){ } . ",
    "url": "/software/modules/pwm_inversion_program.html#50hz_pwm_inverterino",
    
    "relUrl": "/software/modules/pwm_inversion_program.html#50hz_pwm_inverterino"
  },"127": {
    "doc": "PWM Inversion",
    "title": "60Hz_PWM_Inverter.ino",
    "content": "Psuedocode: . | Include the Atinverter library | Create an Atinverter instance set to 60Hz mode | Start PWM generation in 60Hz mode | . Implementation: . #include \"Atinverter.h\" Atinverter atinverter (60); void setup() { atinverter.startPWM(false); } void loop() { } . ",
    "url": "/software/modules/pwm_inversion_program.html#60hz_pwm_inverterino",
    
    "relUrl": "/software/modules/pwm_inversion_program.html#60hz_pwm_inverterino"
  },"128": {
    "doc": "PWM Inversion",
    "title": "PWM Inversion",
    "content": " ",
    "url": "/software/modules/pwm_inversion_program.html",
    
    "relUrl": "/software/modules/pwm_inversion_program.html"
  },"129": {
    "doc": "Scratchpad",
    "title": "Testing",
    "content": "First Term This is the definition of the first term. Second Term This is one definition of the second term. This is another definition of the second term. The world is flat. We now know that the world is round. This sentence uses $ delimiters to show math inline: $\\sqrt{3x-1}+(1+x)^2$ . highlight . X2 . Use `code` in your Markdown file. H20 . I need to highlight these very important words. ",
    "url": "/scratchpad.html#testing",
    
    "relUrl": "/scratchpad.html#testing"
  },"130": {
    "doc": "Scratchpad",
    "title": "Callouts",
    "content": "A paragraph . A paragraph . Another paragraph . The last paragraph . Highlight yellow . Highlight blue . Highlight green . Highlight red . Highlight greylt . Test 2 . A paragraph . A paragraph . Another paragraph . The last paragraph . New title . ‚ÄúWhy not simply use the delay() or millis() functions to accomplish this?‚Äù . ",
    "url": "/scratchpad.html#callouts",
    
    "relUrl": "/scratchpad.html#callouts"
  },"131": {
    "doc": "Scratchpad",
    "title": "Italicizing and Bolding",
    "content": "Lorem ipsum . Lorem ipsum . lorem ipsum . Gone camping! :tent: Be back soon. That is so funny! :joy: . :smile: üòÄ . ",
    "url": "/scratchpad.html#italicizing-and-bolding",
    
    "relUrl": "/scratchpad.html#italicizing-and-bolding"
  },"132": {
    "doc": "Scratchpad",
    "title": "Tables",
    "content": "| head1 | head two | three |:‚Äî‚Äî‚Äî‚Äî-|:‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|:‚Äî‚Äî| ok | good swedish fish | nice | out of stock | good and plenty | nice | ok | good oreos | hmm | ok | good zoute drop | yumm | . ",
    "url": "/scratchpad.html#tables",
    
    "relUrl": "/scratchpad.html#tables"
  },"133": {
    "doc": "Scratchpad",
    "title": "Code  blocks",
    "content": "This is code . const a = 10; static var; . ",
    "url": "/scratchpad.html#code--blocks",
    
    "relUrl": "/scratchpad.html#code--blocks"
  },"134": {
    "doc": "Scratchpad",
    "title": "Creating a Link",
    "content": "Relative link within the directories: This is a link External Link: Arduino Docs . ",
    "url": "/scratchpad.html#creating-a-link",
    
    "relUrl": "/scratchpad.html#creating-a-link"
  },"135": {
    "doc": "Scratchpad",
    "title": "Images",
    "content": ". hey test . oh my . sheesh . The nodes for the library and modules are also interactive‚Äîclick to explore specific software functionality and learn more about its design. ",
    "url": "/scratchpad.html#images",
    
    "relUrl": "/scratchpad.html#images"
  },"136": {
    "doc": "Scratchpad",
    "title": "Putting lines in between",
    "content": "hi . there . ",
    "url": "/scratchpad.html#putting-lines-in-between",
    
    "relUrl": "/scratchpad.html#putting-lines-in-between"
  },"137": {
    "doc": "Scratchpad",
    "title": "Creating an ordered list of items",
    "content": ". | bananas | apples | durian | . ",
    "url": "/scratchpad.html#creating-an-ordered-list-of-items",
    
    "relUrl": "/scratchpad.html#creating-an-ordered-list-of-items"
  },"138": {
    "doc": "Scratchpad",
    "title": "Creating an unordered list of items",
    "content": ". | bananas | apples | durian . | cherries | . | . ",
    "url": "/scratchpad.html#creating-an-unordered-list-of-items",
    
    "relUrl": "/scratchpad.html#creating-an-unordered-list-of-items"
  },"139": {
    "doc": "Scratchpad",
    "title": "Tables",
    "content": "| Col 1 | Col 2 | ‚Äî‚Äì | :‚Äî‚Äì: | . | hello, this is a todo item | hello, this is another todo item | goodbye, this item is done | . graph TD; accTitle: the diamond pattern accDescr: a graph with four nodes: A points to B and C, while B and C both point to D A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; C--&gt;A; D--&gt;E; E--&gt;A; E--&gt;B; . flowchart LR User(circle) --tcp/80 --&gt; LoadBalancer&gt;random shape] --tcp/1337 ---&gt; Webserver{rhombus} . flowchart LR subgraph PublicInternet User end subgraph LoadBalancingZone LoadBalancer end subgraph WebserverZone WebserverA WebserverB end User --tcp/80 --&gt; LoadBalancer LoadBalancer --&gt; WebserverA LoadBalancer --&gt; WebserverB WebserverA --&gt; DatabaseserverA WebserverA -.-&gt; DatabaseserverB WebserverB --&gt; DatabaseserverA WebserverB -.-&gt; DatabaseserverB . pie title A piechart \"SliceA\" : 5 \"SliceB\" : 15 . sankey-beta day, sleep, 8 day, work, 8 day, fun, 2 . A paragraph . Another paragraph . The last paragraph . | Understanding how to communicate between the ADC122S021 and the ATMEGA328P using the SPI protocol for serial transfer of AC voltage data. | . Configuring SPI Protocol . This section describes SPI pins and clock frequency configuration to ensure successful communication. To set the CS, MOSI, and SCLK pins to their desired state, use the following command . #include &lt;SPI.h&gt; . SPI.beginTransaction(SPISettings(1500000, MSBFIRST, SPI_MODE0)); // Configure and start comms . ",
    "url": "/scratchpad.html#tables-1",
    
    "relUrl": "/scratchpad.html#tables-1"
  },"140": {
    "doc": "Scratchpad",
    "title": "üî¢ PWM Timing Calculation (for 50Hz output)",
    "content": "\\(f_{sw} = 31,372Hz\\) \\(f_{sw} = \\frac{1}{f_{sw}} = 31.875\\mu s\\) . ",
    "url": "/scratchpad.html#-pwm-timing-calculation-for-50hz-output",
    
    "relUrl": "/scratchpad.html#-pwm-timing-calculation-for-50hz-output"
  },"141": {
    "doc": "Scratchpad",
    "title": "Scratchpad",
    "content": " ",
    "url": "/scratchpad.html",
    
    "relUrl": "/scratchpad.html"
  },"142": {
    "doc": "Software",
    "title": "Software",
    "content": ". Atinverter V1 Atinverter V2 . ",
    "url": "/software/software.html",
    
    "relUrl": "/software/software.html"
  },"143": {
    "doc": "Timer 2 Delay",
    "title": "Timer 2 Delay Library Feature",
    "content": ". ",
    "url": "/software/library/features/timer2_delay_feature.html#timer-2-delay-library-feature",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#timer-2-delay-library-feature"
  },"144": {
    "doc": "Timer 2 Delay",
    "title": "üìã Overview",
    "content": "An interface is required to handle program delays for time-sensitive operations such as AC voltage sensing and serial communication, among other tasks. üí≠ ‚ÄúWhy not use the Arduino core functions delay(), millis(), or micros() to accomplish this?‚Äù . Although that might seem like the most straightforward approach, the ATMEGA328P Timer0 ‚Äî used by these core functions ‚Äî is also responsible for PWM generation in our hardware. This is described in detail in the PWM Inversion section. If we attempt to use the core delay functions (which reconfigure Timer0 registers), while simultaneously using Timer0 to handle PWM interrupts, we risk introducing conflicting register states. This also translates to erratic behavior in our PWM output which although may not be catastrophic, it is certainly not desired üòÖ. üí≠ ‚ÄúWhy not create a software-based delay program with an incrementer?‚Äù . unsigned long counter = 0; while (counter &lt; SOME_VALUE) { counter++; } . To implement delay2() and millis2(), it‚Äôs not practical to only rely on a simple software incrementer (e.g., counter++) inside a loop to create timing. This would be an approach that requires trial-and-error tuning of a maximum value to achieve a desired delay. In addition, this is inefficient, non-deterministic, and highly sensitive to compiler optimizations or clock speed changes. ",
    "url": "/software/library/features/timer2_delay_feature.html#-overview",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-overview"
  },"145": {
    "doc": "Timer 2 Delay",
    "title": "üí° The Workaround",
    "content": "To resolve this, we developed custom timing functions ‚Äî delay2() and millis2() ‚Äî based on Timer2 from the ATMEGA328P. These serve as effective substitutes for the Arduino core library timing functions, providing a millisecond-based timing mechanism that operates independently of Timer0. ",
    "url": "/software/library/features/timer2_delay_feature.html#-the-workaround",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-the-workaround"
  },"146": {
    "doc": "Timer 2 Delay",
    "title": "‚è±Ô∏è Understanding the Timers on the ATMEGA328P",
    "content": "The ATMEGA328P includes three timers, each with different bit widths: . | Timer0: 8-bit | Timer1: 16-bit | Timer2: 8-bit | . üí≠ ‚ÄúWhat do the ‚Äòbits‚Äô actually mean?‚Äù . The number of bits determines how high a timer can count before it overflows and restarts. Think of it like a clock: . | An 8-bit timer can count from 0 to 255 ($2^8 - 1$) | A 16-bit timer can count from 0 to 65,535 ($2^{16} - 1$) | . A higher bit-width means higher resolution is possible ‚Äî but for a simple 1ms tick, an 8-bit timer like Timer2 is more than sufficient. ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-understanding-the-timers-on-the-atmega328p",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-understanding-the-timers-on-the-atmega328p"
  },"147": {
    "doc": "Timer 2 Delay",
    "title": "üìÇ Library Structure",
    "content": "Implementation in Atinverter.h: . // Timer 2 Increment static volatile unsigned long timer2Millis; // Methods void initTimer2Delay(); void delay2(unsigned long ms); unsigned long millis2(); . ",
    "url": "/software/library/features/timer2_delay_feature.html#-library-structure",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-library-structure"
  },"148": {
    "doc": "Timer 2 Delay",
    "title": "üìù Method Descriptions",
    "content": " ",
    "url": "/software/library/features/timer2_delay_feature.html#-method-descriptions",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#-method-descriptions"
  },"149": {
    "doc": "Timer 2 Delay",
    "title": "void initTimer2Delay()",
    "content": "Purpose: Initializes Timer 2 to generate an interrupt every 1 millisecond. Pseudocode: . | Disable global interrupts | Reset all Timer 2 related registers | Set compare match value for 1ms at 16MHz with 64 prescaler (249) | Set Clear Timer on Compare (CTC) mode | Set pre-scaler to 64 | Enable interrupts on compare match | Enable global interrupts | . Implementation in Atinverter.cpp: . void Atinverter::initTimer2Delay() { cli(); TCCR2A = 0; TCCR2B = 0; TCNT2 = 0; OCR2A = 249; TCCR2A |= (1 &lt;&lt; WGM21); TCCR2B |= (1 &lt;&lt; CS22); TIMSK2 = (1 &lt;&lt; OCIE2A); sei(); } . ",
    "url": "/software/library/features/timer2_delay_feature.html#void-inittimer2delay",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#void-inittimer2delay"
  },"150": {
    "doc": "Timer 2 Delay",
    "title": "void delay2(unsigned long ms)",
    "content": "Purpose: Pauses execution for a specified duration in milliseconds. Pseudocode: . | Record the current millisecond count from timer2Millis | Continuously check if the elapsed time has reached the specified delay | Exit once the condition is met | . Implementation in Atinverter.cpp: . void Atinverter::delay2(unsigned long ms) { unsigned long start = timer2Millis; while ((timer2Millis - start) &lt; ms) { } } . ",
    "url": "/software/library/features/timer2_delay_feature.html#void-delay2unsigned-long-ms",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#void-delay2unsigned-long-ms"
  },"151": {
    "doc": "Timer 2 Delay",
    "title": "unsigned long millis2()",
    "content": "Purpose: Returns the number of milliseconds elapsed since Timer 2 was initialized. Pseudocode: . | Return the current value of timer2Millis | . Implementation in Atinverter.cpp: . unsigned long Atinverter::millis2() { return timer2Millis; } . ",
    "url": "/software/library/features/timer2_delay_feature.html#unsigned-long-millis2",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#unsigned-long-millis2"
  },"152": {
    "doc": "Timer 2 Delay",
    "title": "‚èπÔ∏è ISR Description",
    "content": " ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-isr-description",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-isr-description"
  },"153": {
    "doc": "Timer 2 Delay",
    "title": "ISR(TIMER2_COMPA_vect)",
    "content": "Purpose: Interrupt Service Routine (ISR) for Timer 2 Compare Match A. It increments a global millisecond counter each time Timer 2 reaches its compare value (every 1ms). Pseudocode: . | Increment the timer2Millis counter | . Implementation in Atinverter.cpp: . ISR(TIMER2_COMPA_vect) { Atinverter::timer2Millis++; } . ",
    "url": "/software/library/features/timer2_delay_feature.html#isrtimer2_compa_vect",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#isrtimer2_compa_vect"
  },"154": {
    "doc": "Timer 2 Delay",
    "title": "‚öôÔ∏è Timer2 Delay Initialization",
    "content": "A thorough analysis on how to configure Timer 2 such that its interrupts fire every 1ms. üí≠ ‚ÄúWhy trigger the interrupts every 1ms? Can‚Äôt you use another time frame?‚Äù . Yes, you can definitely use another time frame, but why would you reasonably do that? Consider these reasons why 1ms interrupts are most appropriate: . | ‚òëÔ∏è Arduino‚Äôs built-in millis() and delay() functions are based on 1ms resolution. | üîÑ Simpler math and high enough resolution (1:1 mapping) . | 500 ticks $\\rightarrow$ count to 500 ticks where each counter tick is 1ms instead of 2000 ticks $\\rightarrow$ count to 2000 ticks where each tick is 0.25ms | . | ‚öôÔ∏è Low CPU Overhead . | Operating the CPU at higher frequency can overwhelm the CPU and be more power intensive | . | . Okay now that I hopefully convinced you of why we need 1ms interrupts, here is how we do it: As per the registers described in pages 127-134 of the ATMEGA328P datasheet, these are what we will need to configure. There are 9 registers in total, but we do not need to configure all of them. The registers of interest and what is needed to do is as follows: . üîß TCCR2A ‚Äì Timer/Counter Control Register A . Reset TCCR2A: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TCCR2A = 0; // Reset Timer2 TCCR2A control register . What It Controls: . | Compare Output Modes COM2A[1:0], COM2B[1:0] ‚Äî what happens to OC2A/OC2B (digital 11/3) pins on compare match with TCNT2 | Waveform Generation Mode WGM2[1:0] ‚Äî selects the timer‚Äôs counting behavior (Normal, PWM/Phase Correct, CTC, or Fast PWM) | . What To Set: . | Clear Timer on Compare Match (CTC) mode using WGM21 bit | . TCCR2A |= (1 &lt;&lt; WGM21); // Set CTC mode . üîß TCCR2B ‚Äì Timer/Counter Control Register B . Reset TCCR2B: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TCCR2B = 0; // Reset Timer2 TCCR2B control register . What It Controls: . | Force Output Compare FOC2B, FOC2A ‚Äî forcing a compare match on OC2B/OC2A (digital 3/11) pins | Waveform Generation Mode WGM22 ‚Äî Used with TCCR2A for CTC or fast PWM | Clock Select CS2[2:0] ‚Äî Sets the pre-scaler for the timer clock source | . What To Set: . | Prescaler of 64 using CS22 bit | . TCCR2B |= (1 &lt;&lt; CS22); // Set prescaler = 64 . üîß TCNT2 ‚Äì Timer/Counter Register . Reset TCNT2: . Starts counter at 0, why would you start anywhere else? üòÖ . TCNT2 = 0; // Reset Timer2 TCNT2 control register . What It Controls: . | Timer Counter 2 TCNT2[7:0] ‚Äî The current value of Timer2‚Äôs counter (0-255) | . What To Set: . | Nothing, the timer runs autonomously | . üîß TIMSK2 ‚Äì Timer/Counter2 Interrupt Mask Register . Reset TIMSK2: . Avoids unexpected behavior from previously set states and allows for a known clean slate. TIMSK2 = 0; // Reset Timer2 TIMSK2 control register . What It Controls: . | Output Compare Match Interrupt Enables OCIE2B, OCIE2A ‚Äî Enables an interrupt when the timer value TCNT2 matches the value in OCR2B or OCR2A. | Waveform Generation Mode TOIE2 ‚Äî Enables an interrupt when timer overflows | . What To Set: . | Enable interrupt on Compare Match A using the OCIE2A bit. | . TIMSK2 = (1 &lt;&lt; OCIE2A); // enable compare interrupt . üîß OCR2A ‚Äì Output Compare Register A . What It Controls: . | Holds the top value the TCNT2 counts up to in CTC mode. | When TCNT2 == OCR2A, an interrupt is fired (if enabled), and the counter resets to 0 on the next tick. | . What To Set: . | OCR2A register to 249 | . OCR2A = 249; . Why Set it To 249: . | This value can be computed based on the equation provided in page 121 of the ATMEGA328P datasheet. | . (1) General CTC equation (when toggling pin): . \\[f_{OCnx} = \\frac{f_{clk_{I/O}}}{2 \\times N \\times (1 + OCRnx)}\\] where: . | $OCRnx$ is the output compare register value | $f_{OCnx}$ is the output frequency of the timer/counter | $f_{clk_{I/O}}$ Clock input frequency (16 MHz for ATmega328P) | N is the timer prescale factor (1, 8, 32, 64, 128, 256, or 1024) | ‚Äú2‚Äù in denominator only needed when toggling a pin to generate a waveform | . üîçImportant Note: In interrupt-only CTC mode (no pin toggling), the ‚Äú2‚Äù in the denominator is not included because the interrupt occurs once per timer cycle. Hence, this constant can be ignored. (2) CTC Interrupt-Only Frequency Equation: . \\[f_{OCnx} = \\frac{f_{clk_{I/O}}}{ N \\times (1 + OCRnx)}\\] Now, we can solve for the OCR2A value that produces an interrupt at a frequency of 1kHz (1ms period) by restructuring this equation. (3) CTC Interrupt-Only OCR2A Equation: . \\[OCRnx = \\frac{f_{clk_{I/O}}}{N \\times f_{OCnx}} - 1\\] üî¢ Solving for OCR2A: . \\[OCRnx = \\frac{16*10^6}{64 \\times 1000} - 1 = 249\\] ‚úÖ Result: . Setting OCR2A = 249 results in 1ms timer interrupts using a 16 MHz clock and a prescaler of 64. And we are done! Those are all the registers you need to set. Now when you look at the Timer 2 register initialization, it should now make more sense üòä . ",
    "url": "/software/library/features/timer2_delay_feature.html#%EF%B8%8F-timer2-delay-initialization",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html#Ô∏è-timer2-delay-initialization"
  },"155": {
    "doc": "Timer 2 Delay",
    "title": "Timer 2 Delay",
    "content": ". ",
    "url": "/software/library/features/timer2_delay_feature.html",
    
    "relUrl": "/software/library/features/timer2_delay_feature.html"
  },"156": {
    "doc": "To-Do",
    "title": "TO-DO",
    "content": ". | Order NOR gate and verify that logic protection circuitry is operational | Verify that schematic, PCB, and 3D model is not missing anything (run DRC again just in case) | Load testing captures | Update UML diagram | Update the Vision section, too sparse right now | . ",
    "url": "/todo.html#to-do",
    
    "relUrl": "/todo.html#to-do"
  },"157": {
    "doc": "To-Do",
    "title": "To-Do",
    "content": " ",
    "url": "/todo.html",
    
    "relUrl": "/todo.html"
  },"158": {
    "doc": "Vision",
    "title": "Vision",
    "content": " ",
    "url": "/vision.html",
    
    "relUrl": "/vision.html"
  },"159": {
    "doc": "Vision",
    "title": "Microgrid Significance",
    "content": "Electricity traverses through a large network of interconnected transmission or distribution systems known as the power grid. With the ever-growing demand for electricity and reliable power grid consumption, grid congestion has been a more prominent phenomenon. This occurs when the power grid is unable to deliver the required power to meet demand, particularly from urban area or high demand loads. To alleviate stress on the power grid, microgrids, which are smaller localized electrical systems, can be employed. A microgrid can operate independently or in sync with the main grid and can supply power during power outages. ",
    "url": "/vision.html#microgrid-significance",
    
    "relUrl": "/vision.html#microgrid-significance"
  },"160": {
    "doc": "Vision",
    "title": "EV Inspired PDA Microgrid and Open Source Platforms",
    "content": "As Electric Vehicle (EV) infrastructure continues to develop and gain wider global acceptance, there is growing motivation not only to utilize these systems for transportation but, more importantly, to harness their microgrid capabilities. To more clearly understand this concept, we can consider a power distribution architecture (PDA) for EVs that can: . | intelligently transact power with the grid, | provide important grid-forming and grid-supporting services | share power in a peer-to-peer fashion with other EVs | act as a standalone microgrid that can interface with external AC and DC sources and loads. | operate and communicate between various open source power converters | . Needs to be updated, will write more in this section, but right now giving emphasis to hardware and software documentation!! . ",
    "url": "/vision.html#ev-inspired-pda-microgrid-and-open-source-platforms",
    
    "relUrl": "/vision.html#ev-inspired-pda-microgrid-and-open-source-platforms"
  }
}
